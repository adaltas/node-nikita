// Generated by CoffeeScript 2.5.1
// # `nikita.execute.wait`

// Run a command periodically and continue once the command succeed. Status will be
// set to "false" if the user command succeed right away, considering that no
// change had occured. Otherwise it will be set to "true".   

// ## Example

// ```js
// const {status} = await nikita.execute.wait({
//   command: "test -f /tmp/sth"
// })
// console.info(`Command succeed, the file "/tmp/sth" now exists: ${status}`)
// ```

// ## Schema
var each, handler, schema;

schema = {
  type: 'object',
  properties: {
    'quorum': {
      type: ['integer', 'boolean'],
      description: `Number of minimal successful connection, 50%+1 if "true".`
    },
    'command': {
      oneOf: [
        {
          type: 'string'
        },
        {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      ],
      description: `The commands to be executed.`
    },
    'interval': {
      type: 'integer',
      default: 2000,
      description: `Time interval between which we should wait before re-executing the
command, default to 2s.`
    },
    'code': {
      oneOf: [
        {
          type: 'integer'
        },
        {
          type: 'array',
          items: {
            type: 'integer'
          }
        }
      ],
      description: `Expected exit code to recieve to exit and call the user callback,
default to "0".`
    },
    'code_skipped': {
      oneOf: [
        {
          type: 'integer'
        },
        {
          type: 'array',
          items: {
            type: 'integer'
          }
        }
      ],
      default: 1,
      description: `Expected code to be returned when the command failed and should be
scheduled for later execution, default to "1".`
    },
    'stdin_log': {
      $ref: 'module://@nikitajs/engine/lib/actions/execute#/properties/stdin_log'
    },
    'stdout_log': {
      $ref: 'module://@nikitajs/engine/lib/actions/execute#/properties/stdout_log'
    },
    'stderr_log': {
      $ref: 'module://@nikitajs/engine/lib/actions/execute#/properties/stderr_log'
    }
  },
  required: ['command']
};

// ## Handler
handler = async function({
    config,
    tools: {log}
  }) {
  var command, count, i, len, modified, quorum_current, ref, run;
  if (!Array.isArray(config.command)) {
    // Validate parameters
    config.command = [config.command];
  }
  if (config.quorum && config.quorum === true) {
    config.quorum = Math.ceil(config.command.length / 2);
  } else if (config.quorum == null) {
    config.quorum = config.command.length;
  }
  quorum_current = 0;
  modified = false;
  ref = config.command;
  for (i = 0, len = ref.length; i < len; i++) {
    command = ref[i];
    count = 0;
    if (quorum_current >= config.quorum) {
      break;
    }
    run = async() => {
      var status;
      count++;
      log({
        message: `Attempt #${count}`,
        level: 'INFO'
      });
      ({status} = (await this.execute({
        command: command,
        code: config.code || 0,
        code_skipped: config.code_skipped,
        stdin_log: config.stdin_log,
        stdout_log: config.stdout_log,
        stderr_log: config.stderr_log
      })));
      if (!status) {
        return new Promise(function(resolve) {
          return setTimeout(async function() {
            await run();
            return resolve();
          }, config.interval);
        });
      }
      log({
        message: "Finish wait for execution",
        level: 'INFO'
      });
      quorum_current++;
      if (count > 1) {
        return modified = true;
      }
    };
    await run();
  }
  return {
    status: modified
  };
};

// ## Exports
module.exports = {
  handler: handler,
  metadata: {
    argument_to_config: 'command',
    schema: schema
  }
};

// ## Dependencies
each = require('each');
