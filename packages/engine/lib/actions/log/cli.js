// Generated by CoffeeScript 2.5.1
// # `nikita.log.cli`

// Write log to the host filesystem in a user provided format.

// ## Configuration

// * `depth_max` (number|boolean)    
// * `divider` (string)    
// * `end` (boolean)    
// * `enabled` (boolean)    
// * `host` (string)    
// * `pad` (string)    
// * `time` (boolean)    
//   Print time.   
// * `separator` (string|object)    
// * `stream` (stream.Writable)  

// Global config can be alternatively set with the "log_cli" property.

// ## Example with the depth_max option

// ```js
// nikita
// .log.cli({
//   colors: true,
//   depth_max: 2
// })
// .call({
//   metadata: { 
//     header: 'Print my header'
//   }
// }, function(){
//   @call({
//     metadata: {
//       header: 'Print sub header'
//     }
//   }, function(){
//     @call({
//       metadata: {
//         header: 'Header not printed'
//       }
//     }, function(){
//       // do sth
//     })
//   })
// })
// ```

// ## Example with global config

// ```js
// nikita
// .log.cli({ colors: true })
// .call({
//   metadata: {
//     header: 'Print my header'
//   }
// }, function(){
//   // do sth
// })
// ```

// ## Handler
var colors, get_headers, handler, pad, stream, utils;

handler = function({config, metadata, ssh}) {
  var base, base1, base2, format_line, ids;
  if (metadata.argument != null) {
    // Normalize
    if (config.enabled == null) {
      config.enabled = metadata.argument;
    }
  }
  if (config.enabled == null) {
    config.enabled = true;
  }
  if (config.stream == null) {
    config.stream = process.stderr;
  }
  if (config.end == null) {
    config.end = false;
  }
  if (config.divider == null) {
    config.divider = ' : ';
  }
  if (config.depth_max == null) {
    config.depth_max = false;
  }
  if (config.pad == null) {
    config.pad = {};
  }
  if (config.time == null) {
    config.time = true;
  }
  if (typeof config.separator === 'string') {
    config.separator = {
      host: config.separator,
      header: config.separator
    };
  }
  config.separator = {};
  if ((base = config.separator).host == null) {
    base.host = config.pad.host == null ? '   ' : ' ';
  }
  if ((base1 = config.separator).header == null) {
    base1.header = config.pad.header == null ? '   ' : ' ';
  }
  if ((base2 = config.separator).time == null) {
    base2.time = config.pad.time == null ? '  ' : ' ';
  }
  if (config.host == null) {
    config.host = ssh ? ssh.config.host : 'localhost';
  }
  if (config.colors == null) {
    config.colors = process.stdout.isTTY;
  }
  if (config.colors === true) {
    config.colors = {
      status_true: colors.green,
      status_false: colors.cyan.dim,
      status_error: colors.red
    };
  }
  // Events
  ids = {};
  format_line = function({host, header, status, time}) {
    if (config.pad.host) {
      host = pad(host, config.pad.host);
    }
    if (config.pad.header) {
      header = pad(header, config.pad.header);
    }
    if (config.pad.time) {
      time = pad(time, config.pad.time);
    }
    return [host, config.separator.host, header, config.separator.header, status, config.time ? config.separator.time : '', time].join('');
  };
  return this.call(stream, {
    config: config,
    serializer: {
      'nikita:action:start': function(action) {
        var headers;
        if (!config.enabled) {
          return;
        }
        headers = get_headers(action);
        if (config.depth_max && config.depth_max < headers.length) {
          return;
        }
        ids[action.metadata.index] = action;
        return null;
      },
      // 'diff': null
      'nikita:session:resolved': function() {
        var color, line;
        color = config.colors ? config.colors.status_true : false;
        line = format_line({
          host: config.host,
          header: '',
          status: '♥',
          time: ''
        });
        if (color) {
          line = color(line);
        }
        return line + '\n';
      },
      'nikita:session:rejected': function({error}) {
        var color, line;
        color = config.colors ? config.colors.status_error : false;
        line = format_line({
          host: config.host,
          header: '', // error.message
          status: '✘',
          time: ''
        });
        if (color) {
          line = color(line);
        }
        return line + '\n';
      },
      // 'header': (log) ->
      //   return unless config.enabled
      //   return if config.depth_max and config.depth_max < log.metadata.headers.length
      //   ids[log.index] = log
      //   null
      // 'lifecycle': (log) ->
      //   return unless ids[log.index]
      //   ids[log.index].disabled = true if log.message in ['conditions_failed', 'disabled_true']
      //   null
      'nikita:action:end': function(action, error, output) {
        var color, headers, line, status, time;
        if (!action.metadata.header) {
          return;
        }
        if (config.depth_max && config.depth_max < action.metadata.depth) {
          return;
        }
        // TODO: I don't like this, the `end` event should receive raw output
        // with error not placed inside output by the history plugin
        error = error || action.metadata.relax && output.error;
        status = error ? '✘' : (output != null ? output.status : void 0) && !action.metadata.shy ? '✔' : '-';
        color = false;
        if (config.colors) {
          color = error ? config.colors.status_error : output.status ? config.colors.status_true : config.colors.status_false;
        }
        if (action.metadata.disabled) {
          // action = ids[action.index]
          return null;
        }
        // delete ids[action.index]
        time = config.time ? utils.string.print_time(Date.now() - action.metadata.time) : '';
        headers = get_headers(action);
        line = format_line({
          host: config.host,
          header: headers.join(config.divider),
          status: status,
          time: time
        });
        if (color) {
          line = color(line);
        }
        return line + '\n';
      }
    }
  });
};

// 'stdin': null
// 'stderr': null
// 'stdout': null
// 'text': null

// ## Exports
module.exports = {
  ssh: false,
  handler: handler
};

// ## Dependencies
colors = require('colors/safe');

pad = require('pad');

stream = require('./stream');

utils = require('../../utils');

get_headers = function(action) {
  var headers, walk;
  walk = function(parent) {
    var precious, results;
    precious = parent.metadata.header;
    results = [];
    if (precious !== void 0) {
      results.push(precious);
    }
    if (parent.parent) {
      results.push(...(walk(parent.parent)));
    }
    return results;
  };
  headers = walk(action);
  return headers.reverse();
};
