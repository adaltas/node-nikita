// Generated by CoffeeScript 2.5.1
var handlers, session;

session = require('../session');

// condition_if: (value)
module.exports = function({}) {
  return {
    'nikita:session:normalize': function(args, handler) {
      var conditions, new_action, property, ref, value;
      // return handler
      // Ventilate conditions properties defined at root
      new_action = {};
      conditions = {};
      ref = args.action;
      for (property in ref) {
        value = ref[property];
        if (/^(if|unless)($|_[\w_]+$)/.test(property)) {
          if (conditions[property]) {
            throw Error('CONDITIONS_DUPLICATED_DECLARATION', [`Property ${property} is defined multiple times,`, 'at the root of the action and inside conditions']);
          }
          if (!Array.isArray(value)) {
            value = [value];
          }
          conditions[property] = value;
        } else {
          new_action[property] = value;
        }
      }
      return function() {
        var action;
        arguments[0].action = new_action;
        action = handler.call(null, ...arguments);
        action.conditions = conditions;
        return action;
      };
    },
    'nikita:session:handler:call': async function({action}, handler) {
      var final_run, k, local_run, ref, v;
      final_run = true;
      ref = action.conditions;
      for (k in ref) {
        v = ref[k];
        local_run = (await handlers[k].call(null, action));
        if (local_run === false) {
          final_run = false;
        }
      }
      if (final_run) {
        return handler;
      } else {
        return function() {};
      }
    }
  };
};

handlers = {
  if: async function(action) {
    var condition, final_run, i, len, ref, run;
    final_run = true;
    ref = action.conditions.if;
    for (i = 0, len = ref.length; i < len; i++) {
      condition = ref[i];
      run = (await (async function() {
        switch (typeof condition) {
          case 'undefined':
            return false;
          case 'boolean':
            return condition;
          case 'number':
            return !!condition;
          case 'string':
            return !!condition.length;
          case 'object':
            if (Buffer.isBuffer(condition)) {
              return !!condition.length;
            } else if (condition === null) {
              return false;
            } else {
              return !!Object.keys(condition).length;
            }
            break;
          case 'function':
            return (await session(null, function({run}) {
              return run({
                metadata: {
                  condition: true,
                  depth: action.metadata.depth
                },
                parent: action,
                handler: condition,
                options: action.options
              });
            }));
        }
      })());
      if (run === false) {
        final_run = false;
      }
    }
    return final_run;
  },
  unless: async function(action) {
    var condition, final_run, i, len, ref, run;
    final_run = true;
    ref = action.conditions.unless;
    for (i = 0, len = ref.length; i < len; i++) {
      condition = ref[i];
      run = (await (async function() {
        switch (typeof condition) {
          case 'undefined':
            return true;
          case 'boolean':
            return !condition;
          case 'number':
            return !condition;
          case 'string':
            return !condition.length;
          case 'object':
            if (Buffer.isBuffer(condition)) {
              return !condition.length;
            } else if (condition === null) {
              return true;
            } else {
              return !Object.keys(condition).length;
            }
            break;
          case 'function':
            return !(await session(null, function({run}) {
              return run({
                metadata: {
                  condition: true,
                  depth: action.metadata.depth
                },
                parent: action,
                handler: condition,
                options: action.options
              });
            }));
        }
      })());
      if (run === false) {
        final_run = false;
      }
    }
    return final_run;
  }
};
