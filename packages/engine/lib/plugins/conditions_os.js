// Generated by CoffeeScript 2.5.1
var exec, handlers, session, utils;

session = require('../session');

utils = require('../utils');

exec = require('ssh2-exec');

module.exports = function() {
  return {
    module: '@nikitajs/engine/lib/plugins/conditions_os',
    require: ['@nikitajs/engine/lib/plugins/conditions'],
    hooks: {
      'nikita:session:normalize': {
        after: '@nikitajs/engine/lib/plugins/conditions',
        handler: function(action, handler) {
          return async function() {
            var condition, config, i, j, len, len1, ref;
            action = (await handler.call(null, action));
            if (!action.conditions) {
              return;
            }
            ref = [action.conditions.if_os, action.conditions.unless_os];
            // Normalize conditions
            for (i = 0, len = ref.length; i < len; i++) {
              config = ref[i];
              if (!config) {
                continue;
              }
              for (j = 0, len1 = config.length; j < len1; j++) {
                condition = config[j];
                if (condition.name == null) {
                  condition.name = [];
                }
                if (!Array.isArray(condition.name)) {
                  condition.name = [condition.name];
                }
                if (condition.version == null) {
                  condition.version = [];
                }
                if (!Array.isArray(condition.version)) {
                  condition.version = [condition.version];
                }
                condition.version = utils.semver.sanitize(condition.version, 'x');
                if (condition.arch == null) {
                  condition.arch = [];
                }
                if (!Array.isArray(condition.arch)) {
                  condition.arch = [condition.arch];
                }
              }
            }
            return action;
          };
        }
      },
      'nikita:session:action': {
        after: '@nikitajs/engine/lib/plugins/conditions',
        before: '@nikitajs/engine/lib/metadata/disabled',
        handler: async function(action) {
          var final_run, k, local_run, ref, v;
          final_run = true;
          ref = action.conditions;
          for (k in ref) {
            v = ref[k];
            if (handlers[k] == null) {
              continue;
            }
            local_run = (await handlers[k].call(null, action));
            if (local_run === false) {
              final_run = false;
            }
          }
          if (!final_run) {
            action.metadata.disabled = true;
          }
          return action;
        }
      }
    }
  };
};

handlers = {
  if_os: async function(action) {
    var final_run;
    final_run = true;
    await session(null, function({run}) {
      return run({
        hooks: {
          on_result: function({action}) {
            return delete action.parent;
          }
        },
        metadata: {
          condition: true,
          depth: action.metadata.depth
        },
        parent: action
      }, async function() {
        var arch, match, name, status, stdout, version;
        ({status, stdout} = (await this.execute({
          command: utils.os.os
        })));
        if (!status) {
          return final_run = false;
        }
        [arch, name, version] = stdout.split('|');
        if (name.toLowerCase() === 'red hat') {
          name = 'redhat';
        }
        if (match = /^(\d+)\.(\d+)/.exec(version)) {
          // Remove patch version (eg centos 7.8)
          version = `${match[0]}`;
        }
        match = action.conditions.if_os.some(function(condition) {
          var a, n, v;
          a = !condition.arch.length || condition.arch.some(function(value) {
            if (typeof value === 'string' && value === arch) {
              return true;
            }
            if (value instanceof RegExp && value.test(arch)) {
              return true;
            }
          });
          n = !condition.name.length || condition.name.some(function(value) {
            if (typeof value === 'string' && value === name) {
              return true;
            }
            if (value instanceof RegExp && value.test(name)) {
              return true;
            }
          });
          v = !condition.version.length || condition.version.some(function(value) {
            version = utils.semver.sanitize(version, '0');
            if (typeof value === 'string' && utils.semver.satisfies(version, value)) {
              return true;
            }
            if (value instanceof RegExp && value.test(version)) {
              return true;
            }
          });
          return a && n && v;
        });
        if (!match) {
          return final_run = false;
        }
      });
    });
    return final_run;
  },
  unless_os: async function(action) {
    var final_run;
    final_run = true;
    await session(null, function({run}) {
      return run({
        hooks: {
          on_result: function({action}) {
            return delete action.parent;
          }
        },
        metadata: {
          condition: true,
          depth: action.metadata.depth
        },
        parent: action
      }, async function() {
        var arch, match, name, status, stdout, version;
        ({status, stdout} = (await this.execute({
          command: utils.os.os
        })));
        if (!status) {
          return final_run = false;
        }
        [arch, name, version] = stdout.split('|');
        if (name.toLowerCase() === 'red hat') {
          name = 'redhat';
        }
        if (match = /^(\d+)\.(\d+)/.exec(version)) {
          // Remove patch version (eg centos 7.8)
          version = `${match[0]}`;
        }
        match = action.conditions.unless_os.some(function(condition) {
          var a, n, v;
          a = !condition.arch.length || condition.arch.some(function(value) {
            if (typeof value === 'string' && value === arch) {
              return true;
            }
            if (value instanceof RegExp && value.test(arch)) {
              return true;
            }
          });
          n = !condition.name.length || condition.name.some(function(value) {
            if (typeof value === 'string' && value === name) {
              return true;
            }
            if (value instanceof RegExp && value.test(name)) {
              return true;
            }
          });
          v = !condition.version.length || condition.version.some(function(value) {
            version = utils.semver.sanitize(version, '0');
            if (typeof value === 'string' && utils.semver.satisfies(version, value)) {
              return true;
            }
            if (value instanceof RegExp && value.test(version)) {
              return true;
            }
          });
          return a && n && v;
        });
        if (match) {
          return final_run = false;
        }
      });
    });
    return final_run;
  }
};
