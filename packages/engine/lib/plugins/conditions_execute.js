// Generated by CoffeeScript 2.5.1
var handlers, session;

session = require('../session');

module.exports = {
  name: '@nikitajs/engine/lib/plugins/conditions_execute',
  require: ['@nikitajs/engine/lib/plugins/conditions'],
  hooks: {
    'nikita:session:action': {
      after: '@nikitajs/engine/lib/plugins/conditions',
      before: '@nikitajs/engine/lib/metadata/disabled',
      handler: async function(action) {
        var final_run, k, local_run, ref, v;
        final_run = true;
        ref = action.conditions;
        for (k in ref) {
          v = ref[k];
          if (handlers[k] == null) {
            continue;
          }
          local_run = (await handlers[k].call(null, action));
          if (local_run === false) {
            final_run = false;
          }
        }
        if (!final_run) {
          return action.metadata.disabled = true;
        }
      }
    }
  }
};

handlers = {
  if_execute: async function(action, value) {
    var code_skipped, condition, err, final_run, i, len, ref, ref1, status;
    final_run = true;
    ref = action.conditions.if_execute;
    for (i = 0, len = ref.length; i < len; i++) {
      condition = ref[i];
      try {
        ({status} = (await session({
          hooks: {
            on_result: function({action}) {
              return delete action.parent;
            }
          },
          metadata: {
            condition: true,
            depth: action.metadata.depth,
            namespace: ['execute']
          },
          parent: action
        }, condition)));
        if (!status) {
          final_run = false;
        }
      } catch (error) {
        err = error;
        code_skipped = condition.code_skipped || ((ref1 = condition.config) != null ? ref1.code_skipped : void 0);
        if (code_skipped && parseInt(code_skipped, 10) !== err.exit_code) {
          throw err;
        }
        final_run = false;
      }
    }
    return final_run;
  },
  unless_execute: async function(action) {
    var code_skipped, condition, err, final_run, i, len, ref, ref1, status;
    final_run = true;
    ref = action.conditions.unless_execute;
    for (i = 0, len = ref.length; i < len; i++) {
      condition = ref[i];
      try {
        ({status} = (await session({
          hooks: {
            on_result: function({action}) {
              return delete action.parent;
            }
          },
          metadata: {
            condition: true,
            depth: action.metadata.depth,
            namespace: ['execute']
          },
          parent: action
        }, condition)));
        if (status) {
          final_run = false;
        }
      } catch (error) {
        err = error;
        code_skipped = condition.code_skipped || ((ref1 = condition.config) != null ? ref1.code_skipped : void 0);
        if (code_skipped && parseInt(code_skipped, 10) !== err.exit_code) {
          throw err;
        }
      }
    }
    return final_run;
  }
};
