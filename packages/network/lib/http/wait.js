// Generated by CoffeeScript 2.7.0
// # `nikita.network.http.wait`

// Check if one or multiple hosts listen one or multiple ports periodically over an
// HTTP connection and continue once all the connections succeed. Status will be
// set to "false" if the user connections succeed right away, considering that no
// change had occured. Otherwise it will be set to "true".   

// ## Return

// Status is set to "true" if the first connection attempt was a failure and the 
// connection finaly succeeded.

// ## Schema definitions
var definitions, errors, handler, utils;

definitions = {
  config: {
    type: 'object',
    $ref: 'module://@nikitajs/network/lib/http#/definitions/config',
    properties: {
      'interval': {
        default: 2000, // see https://github.com/ajv-validator/ajv/issues/337
        $ref: 'module://@nikitajs/network/lib/tcp/wait#/definitions/config/properties/interval'
      },
      'status_code': {
        type: 'array',
        default: ['1xx', '2xx', '3xx'],
        items: {
          oneOf: [
            {
              type: 'string'
            },
            {
              instanceof: 'RegExp'
            }
          ]
        },
        description: `Accepted status codes. Accepted values are strings and regular
expressions. String patterns are defined using the \`x\` character.
For example the value \`5xx\` accept all HTTP status code from the 5
class.`
      },
      'timeout': {
        $ref: 'module://@nikitajs/network/lib/tcp/wait#/definitions/config/properties/timeout',
        description: `Maximum time in millisecond to wait until this action is considered
to have failed. When defined, the timeout is applied set to http
request to avoid request hanging.`
      }
    }
  }
};

// ## Handler
handler = async function({
    config,
    tools: {log}
  }) {
  var count, error, start, status_code;
  start = Date.now();
  config.status_code = config.status_code.map(function(item) {
    if (typeof item === 'string') {
      item = new RegExp('^' + item.replaceAll('x', '\\d') + '$');
    }
    return item;
  });
  count = 0;
  while (true) {
    ({error, status_code} = (await this.network.http({
      $relax: true,
      method: config.method,
      url: config.url,
      timeout: config.timeout
    })));
    log({
      message: error ? `Attemp ${count} failed with error` : `Attemp ${count} return status ${status_code}`,
      attempt: count,
      status_code: status_code
    });
    if (!error && config.status_code.some(function(code) {
      return code.test(status_code);
    })) {
      return count > 0;
    }
    if (config.timeout && error.code === 'CURLE_OPERATION_TIMEDOUT') {
      // HTTP request timeout
      throw errors.NIKITA_HTTP_WAIT_TIMEOUT({config});
    }
    await this.wait(config.interval);
    // Action timeout
    if (config.timeout && start + config.timeout < Date.now()) {
      throw errors.NIKITA_HTTP_WAIT_TIMEOUT({config});
    }
    count++;
  }
};

// ## Errors
errors = {
  NIKITA_HTTP_WAIT_TIMEOUT: function({config}) {
    return utils.error('NIKITA_HTTP_WAIT_TIMEOUT', [`timeout reached after ${config.timeout}ms.`]);
  }
};

// ## Exports
module.exports = {
  handler: handler,
  metadata: {
    definitions: definitions
  }
};

// ## Dependencies
utils = require('../utils');
