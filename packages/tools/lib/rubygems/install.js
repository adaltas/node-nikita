// Generated by CoffeeScript 2.6.1
  // # `nikita.tools.rubygems.install`

// Install a Ruby gem.

// Ruby gems package a ruby library with a common layout. Inside gems are the 
  // following components:

// - Code (including tests and supporting utilities)
  // - Documentation
  // - gemspec

// ## Example

// Install a gem from its name and version:

// ```js
  // const {$status} = await nikita.tools.rubygems.install({
  //   name: 'json',
  //   version: '2.1.0',
  // })
  // console.info(`Gem installed: ${$status}`)
  // ```

// Install a gem from a local file:

// ```js
  // const {$status} = await nikita.tools.rubygems.install({
  //   source: '/path/to/json-2.1.0.gem'
  // })
  // console.info(`Gem installed: ${$status}`)
  // ```

// Install gems from a glob expression:

// ```js
  // const {$status} = await nikita.tools.rubygems.install({
  //   source: '/path/to/*.gem',
  // })
  // console.info(`Gem installed: ${$status}`)
  // ```

// ## Schema definitions
var definitions, handler, semver, utils,
  indexOf = [].indexOf;

definitions = {
  config: {
    type: 'object',
    properties: {
      'bindir': {
        type: 'string',
        description: `Directory where binary files are located.`
      },
      'build_flags': {
        type: 'string',
        description: `Pass flags to the compiler.`
      },
      'bash': {
        $ref: 'module://@nikitajs/core/lib/actions/execute#/definitions/config/properties/bash'
      },
      'gem_bin': {
        type: 'string',
        default: 'gem',
        description: `Path to the gem command.`
      },
      'name': {
        type: 'string',
        description: `Name of the gem.`
      },
      'source': {
        type: 'string',
        description: `Path to the gem package.`
      },
      'target': {
        type: 'string',
        description: `Install directory.`
      },
      'version': {
        type: 'string',
        description: `Version of the gem.`
      }
    },
    required: ['name']
  }
};

// ## Handler
handler = async function({
    config,
    ssh,
    tools: {path}
  }) {
  var current_filenames, current_gems, files, gems, i, is_version_matching, j, k, len, len1, line, name, name1, ref, ref1, source, sources, stdout, v, version, versions;
  // Global config
  if (config.ruby == null) {
    config.ruby = {};
  }
  ref = config.ruby;
  for (k in ref) {
    v = ref[k];
    if (config[k] == null) {
      config[k] = v;
    }
  }
  gems = {};
  if (gems[name1 = config.name] == null) {
    gems[name1] = config.version;
  }
  // Get all current gems
  current_gems = {};
  ({stdout} = (await this.execute({
    $shy: true,
    command: `${config.gem_bin} list --versions`,
    bash: config.bash
  })));
  ref1 = utils.string.lines(stdout);
  for (i = 0, len = ref1.length; i < len; i++) {
    line = ref1[i];
    if (line.trim() === '') {
      continue;
    }
    [name, version] = line.match(/(.*?)(?:$| \((?:default:\s+)?([\d\., ]+)\))/).slice(1, 4);
    current_gems[name] = version.split(', ');
  }
  // Make array of sources and filter
  sources = [];
  if (config.source) {
    ({files} = (await this.fs.glob(config.source)));
    current_filenames = [];
    for (name in current_gems) {
      versions = current_gems[name];
      for (j = 0, len1 = versions.length; j < len1; j++) {
        version = versions[j];
        current_filenames.push(`${name}-${version}.gem`);
      }
    }
    sources = files.filter(function(source) {
      var filename;
      filename = path.basename(source);
      if (indexOf.call(current_filenames, filename) < 0) {
        return true;
      }
    });
  }
// Filter gems
  for (name in gems) {
    version = gems[name];
    if (!current_gems[name]) {
      // Install if Gem isnt yet there
      continue;
    }
    // Install if a version is demanded and no installed version satisfy it
    is_version_matching = current_gems[name].some(function(current_version) {
      return semver.satisfies(version, current_version);
    });
    if (version && !is_version_matching) {
      continue;
    }
    delete gems[name];
  }
  // Install from sources
  if (sources.length) {
    await this.execute({
      command: ((function() {
        var l, len2, results;
        results = [];
        for (l = 0, len2 = sources.length; l < len2; l++) {
          source = sources[l];
          results.push([`${config.gem_bin}`, "install", config.bindir ? `--bindir '${config.bindir}'` : void 0, config.target ? `--install-dir '${config.target}'` : void 0, source ? `--local '${source}'` : void 0, config.build_flags ? "--build-flags config.build_flags" : void 0].join(' '));
        }
        return results;
      })()).join('\n'),
      code: [0, 2],
      bash: config.bash
    });
  }
  // Install from gems
  if (Object.keys(gems).length) {
    return (await this.execute({
      command: ((function() {
        var results;
        results = [];
        for (name in gems) {
          version = gems[name];
          results.push([`${config.gem_bin}`, "install", `${name}`, config.bindir ? `--bindir '${config.bindir}'` : void 0, config.target ? `--install-dir '${config.target}'` : void 0, version ? `--version '${version}'` : void 0, config.build_flags ? "--build-flags config.build_flags" : void 0].join(' '));
        }
        return results;
      })()).join('\n'),
      code: [0, 2],
      bash: config.bash
    }));
  }
};

// ## Exports
module.exports = {
  handler: handler,
  metadata: {
    global: 'ruby',
    definitions: definitions
  }
};

// ## Dependencies
semver = require('semver');

utils = require('../utils');
