// Generated by CoffeeScript 2.6.1
// # `nikita.tools.repo`

// Setup packet manager repository. Only support yum for now.

// ## Example

// ```js
// const {$status} = await nikita.tools.repo({
//   source: '/tmp/centos.repo',
//   clean: 'CentOs*'
// })
// console.info(`Repo was updated: ${$status}`)
// ```

// ## Schema definitions
var definitions, handler, utils;

definitions = {
  config: {
    type: 'object',
    properties: {
      'content': {
        type: ['string', 'object'],
        description: `Content to write inside the file.`
      },
      'clean': {
        type: 'string',
        description: `Globing expression used to match replaced files. When relative, the
path is resolved to the parent target directory which is
'/etc/yum.repos.d' when the target is a filename.`
      },
      'gpg_dir': {
        type: 'string',
        default: '/etc/pki/rpm-gpg',
        description: `Directory storing GPG keys.`
      },
      'source': {
        type: 'string',
        description: `The source file containing the repository`
      },
      'target': {
        type: 'string',
        description: `Path of the repository definition file, relative to
'/etc/yum.repos.d'.`
      },
      'update': {
        type: 'boolean',
        default: false,
        description: `Run yum update enabling only the ids present in repo file.`
      },
      'verify': {
        type: 'boolean',
        default: true,
        description: `Download the PGP keys if it's enabled in the repo file, keys are by
default placed inside "/etc/pki/rpm-gpg" defined by the gpg_dir option
and the filename is derivated from the url.`
      }
    },
    oneOf: [
      {
        required: ['content']
      },
      {
        required: ['source']
      }
    ]
  }
};

// ## Handler
handler = async function({
    config,
    tools: {log, path}
  }) {
  var $status, data, file, files, i, key, keys, len, name, remote_files, repoids, section;
  if (config.source != null) {
    // TODO wdavidw 180115, target should be mandatory and not default to the source filename
    if (config.target == null) {
      config.target = path.resolve("/etc/yum.repos.d", path.basename(config.source));
    }
  }
  config.target = path.resolve('/etc/yum.repos.d', config.target);
  if (config.clean) {
    config.clean = path.resolve(path.dirname(config.target), config.clean);
  }
  remote_files = [];
  repoids = [];
  // Delete
  if (config.clean) {
    log({
      message: "Searching repositories inside \"/etc/yum.repos.d/\"",
      level: 'DEBUG',
      module: 'nikita/lib/tools/repo'
    });
    ({files} = (await this.fs.glob(config.clean)));
    remote_files = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (file === config.target) {
          continue;
        }
        results.push(file);
      }
      return results;
    })();
  }
  await this.fs.remove(remote_files);
  // Download source
  await this.file.download({
    $if: config.source != null,
    source: config.source,
    target: config.target,
    headers: config.headers,
    md5: config.md5,
    proxy: config.proxy,
    location: config.location,
    cache: false
  });
  // Write
  await this.file.types.yum_repo({
    $if: config.content != null,
    content: config.content,
    mode: config.mode,
    uid: config.uid,
    gid: config.gid,
    target: config.target
  });
  // Parse the definition file
  keys = [];
  log(`Read GPG keys from ${config.target}`, {
    level: 'DEBUG',
    module: 'nikita/lib/tools/repo'
  });
  ({data} = (await this.fs.base.readFile({
    target: config.target,
    encoding: 'utf8'
  })));
  data = utils.ini.parse_multi_brackets(data);
  keys = (function() {
    var results;
    results = [];
    for (name in data) {
      section = data[name];
      repoids.push(name);
      if (section.gpgcheck !== '1') {
        continue;
      }
      if (section.gpgkey == null) {
        throw Error('Missing gpgkey');
      }
      if (!/^http(s)??:\/\//.test(section.gpgkey)) {
        continue;
      }
      results.push(section.gpgkey);
    }
    return results;
  })();
  // Download GPG Keys
  if (config.verify) {
    for (i = 0, len = keys.length; i < len; i++) {
      key = keys[i];
      log(`Downloading GPG keys from ${key}`, {
        level: 'DEBUG',
        module: 'nikita/lib/tools/repo'
      });
      ({$status} = (await this.file.download({
        source: key,
        target: `${config.gpg_dir}/${path.basename(key)}`
      })));
      ({$status} = (await this.execute({
        $if: $status,
        command: `rpm --import ${config.gpg_dir}/${path.basename(key)}`
      })));
    }
  }
  // Clean Metadata
  ({$status} = (await this.execute({
    $if: path.relative('/etc/yum.repos.d', config.target) !== '..' && $status,
    // wdavidw: 180114, was "yum clean metadata"
    // explanation is provided in case of revert.
    // expire-cache is much faster, it forces yum to go redownload the small
    // repo files only, then if there's newer repo data, it will downloaded it.
    command: 'yum clean expire-cache; yum repolist -y'
  })));
  if (config.update && $status) {
    return (await this.execute({
      command: `yum update -y --disablerepo=* --enablerepo='${repoids.join(',')}'
yum repolist`,
      trap: true
    }));
  }
};

// ## Exports
module.exports = {
  handler: handler,
  metadata: {
    definitions: definitions
  }
};

// ## Dependencies
utils = require('@nikitajs/file/lib/utils');
