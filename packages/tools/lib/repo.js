// Generated by CoffeeScript 2.6.1
// # `nikita.tools.repo`

// Setup packet manager repository. Only support yum for now.

// ## Example

// ```js
// const {$status} = await nikita.tools.repo({
//   source: '/tmp/centos.repo',
//   clean: 'CentOs*'
// })
// console.info(`Repo was updated: ${$status}`)
// ```

// ## Schema definitions
var definitions, handler, url, utils;

definitions = {
  config: {
    type: 'object',
    properties: {
      'content': {
        type: ['string', 'object'],
        description: `Content to write inside the repository definition file.`
      },
      'clean': {
        type: 'string',
        description: `Globing expression used to match replaced files. When relative, the
path is resolved to the parent target directory which is
'/etc/yum.repos.d' when the target is a filename.`
      },
      'gpg_dir': {
        type: 'string',
        default: '/etc/pki/rpm-gpg',
        description: `Directory storing GPG keys.`
      },
      'gpg_key': {
        type: 'string',
        description: `Import specified key into the gpg_dir specified, downloads
the file if it's an url.`
      },
      'local': {
        $ref: 'module://@nikitajs/file/lib/index#/definitions/config/properties/local',
        default: false
      },
      'source': {
        type: 'string',
        description: `The source file containing the repository definition file.`
      },
      'target': {
        type: 'string',
        description: `Path of the repository definition file, relative to
'/etc/yum.repos.d'.`
      },
      'update': {
        type: 'boolean',
        default: false,
        description: `Run yum update enabling only the ids present in repo file.`
      },
      'verify': {
        type: 'boolean',
        default: true,
        description: `Download the PGP keys if it's enabled in the repo file, keys are by
default placed inside "/etc/pki/rpm-gpg" defined by the gpg_dir option
and the filename is derivated from the url.`
      }
    },
    oneOf: [
      {
        required: ['content']
      },
      {
        required: ['source']
      }
    ]
  }
};

// ## Handler
handler = async function({
    config,
    ssh,
    tools: {log, path}
  }) {
  var $status, data, file, files, i, isFile, key, keys, len, name, remote_files, repoids, section;
  if (config.source != null) {
    // TODO wdavidw 180115, target should be mandatory and not default to the source filename
    if (config.target == null) {
      config.target = path.resolve("/etc/yum.repos.d", path.basename(config.source));
    }
  }
  config.target = path.resolve('/etc/yum.repos.d', config.target);
  if (config.clean) {
    config.clean = path.resolve(path.dirname(config.target), config.clean);
  }
  remote_files = [];
  repoids = [];
  // Delete
  if (config.clean) {
    log({
      message: "Searching repositories inside \"/etc/yum.repos.d/\"",
      level: 'DEBUG',
      module: 'nikita/lib/tools/repo'
    });
    ({files} = (await this.fs.glob(config.clean)));
    remote_files = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (file === config.target) {
          continue;
        }
        results.push(file);
      }
      return results;
    })();
  }
  await this.fs.remove(remote_files);
  // Use download unless we are over ssh, in such case,
  // the source default to target host unless local is provided
  isFile = config.source && url.parse(config.source).protocol === null;
  if ((config.source != null) && (!isFile || (ssh != null) && (config.local != null))) {
    await this.file.download({
      cache: false,
      gid: config.gid,
      headers: config.headers,
      location: config.location,
      md5: config.md5,
      mode: config.mode,
      proxy: config.proxy,
      source: config.source,
      target: config.target,
      uid: config.uid
    });
  } else if (config.source != null) {
    await this.fs.copy({
      gid: config.gid,
      mode: config.mode,
      source: config.source,
      target: config.target,
      uid: config.uid
    });
  } else if (config.content != null) {
    await this.file.types.yum_repo({
      content: config.content,
      gid: config.gid,
      mode: config.mode,
      target: config.target,
      uid: config.uid
    });
  }
  // Parse the definition file
  keys = [];
  log(`Read GPG keys from ${config.target}`, {
    level: 'DEBUG',
    module: 'nikita/lib/tools/repo'
  });
  ({data} = (await this.fs.base.readFile({
    target: config.target,
    encoding: 'utf8'
  })));
  data = utils.ini.parse_multi_brackets(data);
  keys = (function() {
    var results;
    results = [];
    for (name in data) {
      section = data[name];
      repoids.push(name);
      if (section.gpgcheck !== '1') {
        continue;
      }
      if (!(config.gpg_key || (section.gpgkey != null))) {
        throw Error('Missing gpgkey');
      }
      if (!/^http(s)??:\/\//.test(section.gpgkey)) {
        continue;
      }
      results.push(section.gpgkey);
    }
    return results;
  })();
  if (config.gpg_key) {
    keys.push(config.gpg_key);
  }
  // Download GPG Keys
  if (config.verify) {
    for (i = 0, len = keys.length; i < len; i++) {
      key = keys[i];
      log(`Downloading GPG keys from ${key}`, {
        level: 'DEBUG',
        module: 'nikita/lib/tools/repo'
      });
      ({$status} = (await this.file.download({
        source: key,
        target: `${config.gpg_dir}/${path.basename(key)}`
      })));
      ({$status} = (await this.execute({
        $if: $status,
        command: `rpm --import ${config.gpg_dir}/${path.basename(key)}`
      })));
    }
  }
  // Clean Metadata
  ({$status} = (await this.execute({
    $if: path.relative('/etc/yum.repos.d', config.target) !== '..' && $status,
    // wdavidw: 180114, was "yum clean metadata"
    // explanation is provided in case of revert.
    // expire-cache is much faster, it forces yum to go redownload the small
    // repo files only, then if there's newer repo data, it will downloaded it.
    command: 'yum clean expire-cache; yum repolist -y'
  })));
  if (config.update && $status) {
    return (await this.execute({
      command: `yum update -y --disablerepo=* --enablerepo='${repoids.join(',')}'
yum repolist`,
      trap: true
    }));
  }
};

// ## Exports
module.exports = {
  handler: handler,
  metadata: {
    definitions: definitions
  }
};

// ## Dependencies
utils = require('@nikitajs/file/lib/utils');

url = require('url');
