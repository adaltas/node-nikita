// Generated by CoffeeScript 2.6.1
// # `nikita.krb5.ktutil.add`

// Create and manage a keytab for an existing principal. It's different than ktadd
// in the way it can manage several principal on one keytab.

// ## Example

// ```js
// const {$status} = await nikita.krb5.ktutil.add({
//   principal: 'myservice/my.fqdn@MY.REALM',
//   keytab: '/etc/security/keytabs/my.service.keytab',
//   password: 'password'
// })
// console.info(`Keytab was created or modified: ${$status}`)
// ```

// ## Schema definitions
var definitions, handler, mutate, utils;

definitions = {
  config: {
    type: 'object',
    properties: {
      'admin': {
        $ref: 'module://@nikitajs/krb5/lib/execute#/definitions/config/properties/admin'
      },
      'enctypes': {
        type: 'array',
        items: {
          type: 'string'
        },
        default: ['aes256-cts-hmac-sha1-96', 'aes128-cts-hmac-sha1-96', 'des3-cbc-sha1', 'arcfour-hmac'],
        description: `The enctypes used by krb5_server.`
      },
      'gid': {
        $ref: 'module://@nikitajs/file/lib/index#/definitions/config/properties/gid'
      },
      'keytab': {
        type: 'string',
        description: `Path to the file storing key entries.`
      },
      'mode': {
        $ref: 'module://@nikitajs/file/lib/index#/definitions/config/properties/mode'
      },
      'password': {
        type: 'string',
        description: `Password associated to this principal; required if no randkey is
provided.`
      },
      'principal': {
        type: 'string',
        description: `Principal to be created.`
      },
      'realm': {
        type: 'string',
        description: `The realm the principal belongs to.`
      },
      'uid': {
        $ref: 'module://@nikitajs/file/lib/index#/definitions/config/properties/uid'
      }
    },
    required: ['keytab', 'password', 'principal']
  }
};

// ## Handler
handler = async function({
    config,
    tools: {log}
  }) {
  var $status, _, code, command, enctype, entries, entry, i, j, k, kvno, len, len1, len2, line, match, mdate, princ, princ_entries, principal, ref, ref1, ref2, slot, stdout, timestamp, tmp_keytab, values;
  if (/^\S+@\S+$/.test(config.principal)) {
    if (config.realm == null) {
      config.realm = config.principal.split('@')[1];
    }
  } else {
    if (!config.realm) {
      throw Error('Property "realm" is required in principal');
    }
    config.principal = `${config.principal}@${config.realm}`;
  }
  entries = [];
  princ_entries = [];
  princ = {};
  command = null;
  // Get keytab entries
  ({$status, stdout, code} = (await this.execute({
    $shy: true,
    command: `echo -e 'rkt ${config.keytab}\nlist -e -t \n' | ktutil`,
    code_skipped: 1
  })));
  if ($status) {
    log({
      message: "Principal exist in Keytab, check kvno validity",
      level: 'DEBUG'
    });
    ref = utils.string.lines(stdout);
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      if (!(match = /^\s*(\d+)\s*(\d+)\s+([\d\/:]+\s+[\d\/:]+)\s+(.*)\s*\(([\w|-]*)\)\s*$/.exec(line))) {
        continue;
      }
      [_, slot, kvno, timestamp, principal, enctype] = match;
      kvno = parseInt(kvno, 10);
      entries.push({
        slot: slot,
        kvno: kvno,
        timestamps: timestamp,
        principal: principal.trim(),
        enctype: enctype
      });
    }
    princ_entries = entries.filter(function(e) {
      return `${e.principal}` === `${config.principal}`;
    }).reverse();
  }
  // Get principal information and compare to keytab entries kvnos
  ({$status, stdout} = (await this.krb5.execute({
    $shy: true,
    admin: config.admin,
    command: `getprinc -terse ${config.principal}`
  })));
  if ($status) {
    values = utils.string.lines(stdout)[1];
    if (!values) {
      // Check if a ticket exists for this
      throw Error(`Principal does not exist: '${config.principal}'`);
    }
    values = values.split('\t');
    mdate = parseInt(values[2], 10) * 1000;
    kvno = parseInt(values[8], 10);
    princ = {
      mdate: mdate,
      kvno: kvno
    };
  }
  // read keytab and check kvno validities
  command = null;
  tmp_keytab = `${config.keytab}.tmp_nikita_${Date.now()}`;
  ref1 = config.enctypes;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    enctype = ref1[j];
    entry = princ_entries.filter(function(entry) {
      return entry.enctype === enctype;
    }).length === 1 ? entries.filter(function(entry) {
      return entry.enctype === enctype;
    })[0] : null;
    //entries.filter( (entry) -> entry.enctype is enctype).length is 1
    // add_entry_command = "add_entry -password -p #{config.principal} -k #{princ.kvno} -e #{enctype}\n#{config.password}\n"
    if ((entry != null) && ((entry != null ? entry.kvno : void 0) !== princ.kvno)) {
      if (command == null) {
        command = `echo -e 'rkt ${config.keytab}\n`;
      }
      // remove entry if kvno not identical
      log({
        message: `Remove from Keytab kvno '${entry.kvno}', principal kvno '${princ.kvno}'`,
        level: 'INFO'
      });
      command += `delete_entry ${entry != null ? entry.slot : void 0}\n`;
    }
  }
  if (entries.length > princ_entries.length) {
    if (command != null) {
      await this.execute({
        command: command + `wkt ${tmp_keytab}\nquit\n' | ktutil`
      });
    }
    if (command != null) {
      await this.fs.move({
        source: tmp_keytab,
        target: config.keytab
      });
    }
  }
  if ((entries.length === princ_entries.length) && (command != null)) {
    await this.fs.remove({
      target: config.keytab
    });
  }
  // write entries in keytab
  command = null;
  ref2 = config.enctypes;
  for (k = 0, len2 = ref2.length; k < len2; k++) {
    enctype = ref2[k];
    entry = princ_entries.filter(function(entry) {
      return entry.enctype === enctype;
    }).length === 1 ? entries.filter(function(entry) {
      return entry.enctype === enctype;
    })[0] : null;
    if (((entry != null ? entry.kvno : void 0) !== princ.kvno) || (entry == null)) {
      if (command == null) {
        command = "echo -e '";
      }
      command += `add_entry -password -p ${config.principal} -k ${princ.kvno} -e ${enctype}\n${config.password}\n`;
    }
  }
  if (command != null) {
    await this.execute({
      command: command + `wkt ${config.keytab}\n' | ktutil`
    });
  }
  // Keytab ownership and permissions
  if ((config.uid != null) || (config.gid != null)) {
    await this.fs.chown({
      target: config.keytab,
      uid: config.uid,
      gid: config.gid
    });
  }
  if (!config.mode) {
    return;
  }
  return (await this.fs.chmod({
    target: config.keytab,
    mode: config.mode
  }));
};

// ## Exports
module.exports = {
  handler: handler,
  metadata: {
    global: 'krb5',
    definitions: definitions
  }
};

// ## Fields in 'getprinc -terse' output

// princ-canonical-name
// princ-exp-time
// last-pw-change
// pw-exp-time
// princ-max-life
// modifying-princ-canonical-name
// princ-mod-date
// princ-attributes <=== This is the field you want
// princ-kvno
// princ-mkvno
// princ-policy (or 'None')
// princ-max-renewable-life
// princ-last-success
// princ-last-failed
// princ-fail-auth-count
// princ-n-key-data
// ver
// kvno
// data-type[0]
// data-type[1]

// ## Dependencies
utils = require('@nikitajs/core/lib/utils');

({mutate} = require('mixme'));
