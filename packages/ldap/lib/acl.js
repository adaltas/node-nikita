// Generated by CoffeeScript 2.6.1
// # `nikita.ldap.acl`

// Create new [ACLs](acls) for the OpenLDAP server.

// ## Example

// ```js
// const {$status} = await nikita.ldap.acl({
//   dn: '',
//   acls: [{
//     place_before: 'dn.subtree="dc=domain,dc=com"',
//     to: 'dn.subtree="ou=users,dc=domain,dc=com"',
//     by: [
//       'dn.exact="ou=users,dc=domain,dc=com" write',
//       'dn.base="gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth" read',
//       '* none'
//     ]
//   },{
//     to: 'dn.subtree="dc=domain,dc=com"',
//     by: [
//       'dn.exact="ou=kerberos,dc=domain,dc=com" write'
//     ]
//   }]
// })
// console.info(`ACL modified: ${$status}`)
// ```

// ## Hooks
var definitions, handler, is_object_literal, merge, on_action, utils;

on_action = function({config}) {
  if (is_object_literal(config.acls)) {
    return config.acls = [config.acls];
  }
};

// ## Schema definitions
definitions = {
  config: {
    type: 'object',
    properties: {
      'acls': {
        type: 'array',
        description: `In case of multiple acls, regroup "place_before", "to" and "by" as an
array.`,
        items: {
          type: 'object',
          properties: {
            'by': {
              type: 'array',
              items: {
                type: 'string'
              },
              description: `Who to grant access to and the access to grant as an array (eg:
\`{..., by:["ssf=64 anonymous auth"]}\`).`
            },
            'first': {
              type: 'boolean',
              description: `Please ACL in the first position.`
            },
            'place_before': {
              type: 'string',
              description: `Place before another rule defined by "to".`
            },
            'to': {
              type: 'string',
              description: `What to control access to as a string.`
            }
          }
        }
      },
      'dn': {
        type: 'string',
        description: `Distinguish name storing the "olcAccess" property, using the database
address (eg: "olcDatabase={2}bdb,cn=config").`
      },
      'suffix': {
        type: 'string',
        description: `The suffix associated with the database (eg: "dc=example,dc=org"),
used as an alternative to the \`dn\` configuration.`
      }
    },
    required: ['acls']
  }
};

// ## Handler
handler = async function({
    config,
    tools: {log}
  }) {
  var $status, access, access_by, acl, acl_by, current, dn, found, i, index, is_perfect_match, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, line, m, match, n, not_found_acl, o, olcAccess, olcAccesses, old, operations, p, q, ref, ref1, ref2, ref3, ref4, stdout;
  $status = false;
  // Get DN
  if (!config.dn) {
    log({
      message: "Get DN of the database to modify",
      level: 'DEBUG'
    });
    ({dn} = (await this.ldap.tools.database(config, {
      suffix: config.suffix
    })));
    config.dn = dn;
    log({
      message: `Database DN is ${dn}`,
      level: 'INFO'
    });
  }
  ref = config.acls;
  for (j = 0, len = ref.length; j < len; j++) {
    acl = ref[j];
    // Get ACLs
    log({
      message: "List all ACL of the directory",
      level: 'DEBUG'
    });
    ({stdout} = (await this.ldap.search(config, {
      attributes: ['olcAccess'],
      base: `${config.dn}`,
      filter: '(olcAccess=*)'
    })));
    current = null;
    olcAccesses = [];
    ref1 = utils.string.lines(stdout);
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      line = ref1[k];
      if (match = /^olcAccess: (.*)$/.exec(line)) {
        if (current != null) {
          olcAccesses.push(current); // Push previous rule
        }
        current = match[1];
      } else if (current != null) {
        if (/^ /.test(line)) { // Append to existing rule
          current += line.substr(1); // Close the rule
        } else {
          olcAccesses.push(current);
          current = null;
        }
      }
    }
    olcAccesses = utils.ldap.acl.parse(olcAccesses);
    // Diff
    olcAccess = null;
// Find match "to" property
    for (i = l = 0, len2 = olcAccesses.length; l < len2; i = ++l) {
      access = olcAccesses[i];
      if (acl.to === access.to) {
        olcAccess = merge(access);
        olcAccess.old = access;
        break;
      }
    }
    if (olcAccess) { // Modify rule or bypass perfect match
      is_perfect_match = true;
      not_found_acl = [];
      if (acl.by.length !== olcAccess.by.length) {
        is_perfect_match = false;
      } else {
        ref2 = acl.by;
        for (i = m = 0, len3 = ref2.length; m < len3; i = ++m) {
          acl_by = ref2[i];
          if (acl_by !== olcAccess.by[i]) {
            is_perfect_match = false;
          }
          found = true;
          ref3 = olcAccess.by;
          for (n = 0, len4 = ref3.length; n < len4; n++) {
            access_by = ref3[n];
            if (acl_by !== access_by) {
              found = false;
            }
          }
          if (!found) {
            not_found_acl.push(acl_by);
          }
        }
      }
      if (is_perfect_match) {
        log({
          message: "No modification to apply",
          level: 'INFO'
        });
        continue;
      }
      if (not_found_acl.length) {
        log({
          message: "Modify access after undefined acl",
          level: 'INFO'
        });
        ref4 = olcAccess.by;
        for (o = 0, len5 = ref4.length; o < len5; o++) {
          access_by = ref4[o];
          not_found_acl.push(access_by);
        }
        olcAccess.by = not_found_acl;
      } else {
        log({
          message: "Modify access after reorder",
          level: 'INFO'
        });
        if (typeof log === "function") {
          log('nikita `ldap.acl`: m');
        }
        olcAccess.by = acl.by;
      }
    } else {
      log({
        message: "Insert a new access",
        level: 'INFO'
      });
      index = olcAccesses.length;
      if (acl.first) { // not tested
        index = 0;
      }
      if (acl.place_before) {
        for (i = p = 0, len6 = olcAccesses.length; p < len6; i = ++p) {
          access = olcAccesses[i];
          if (access.to === acl.place_before) {
            index = i;
          }
        }
      } else if (acl.after) {
        for (i = q = 0, len7 = olcAccesses.length; q < len7; i = ++q) {
          access = olcAccesses[i];
          if (access.to === config.after) {
            index = i + 1;
          }
        }
      }
      olcAccess = {
        index: index,
        to: acl.to,
        by: acl.by,
        add: true
      };
    }
    if (olcAccess.old) {
      // Save
      old = utils.ldap.acl.stringify(olcAccess.old);
    }
    olcAccess = utils.ldap.acl.stringify(olcAccess);
    operations = {
      dn: config.dn,
      changetype: 'modify',
      attributes: []
    };
    if (old) {
      operations.attributes.push({
        type: 'delete',
        name: 'olcAccess'
      });
      operations.attributes.push({
        type: 'add',
        name: 'olcAccess',
        value: olcAccess
      });
    } else {
      operations.attributes.push({
        type: 'add',
        name: 'olcAccess',
        value: olcAccess
      });
    }
    await this.ldap.modify(config, {
      operations: operations
    });
    $status = true;
  }
  return $status;
};

// ## Exports
module.exports = {
  handler: handler,
  hooks: {
    on_action: on_action
  },
  metadata: {
    global: 'ldap',
    definitions: definitions
  }
};

// ## Dependencies
({is_object_literal, merge} = require('mixme'));

utils = require('./utils');

// [acls]: http://www.openldap.org/doc/admin24/access-control.html
// [tuto]: https://documentation.fusiondirectory.org/fr/documentation/convert_acl
