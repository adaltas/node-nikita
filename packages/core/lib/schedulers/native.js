// Generated by CoffeeScript 2.5.1
var is_object_literal, merge, utils;

utils = require('../utils');

({is_object_literal, merge} = require('mixme'));

module.exports = function(tasks, options = {}) {
  var clear_managed_tasks, count_pending_tasks, promise, scheduler, state;
  scheduler = null;
  // Managed tasks are resolved inside the scheduler promise. The promise
  // fulfill with an array which length is the number of managed tasks.
  // It is possible to defined `managed` globally for every handler and
  // individually for each handler when calling `push` or `unshift`.
  // By default, tasks passed in the scheduler creation are managed while
  // handler pushed or unshifted are not.
  // It is not possible to register managed handler once the scheduler has
  // resolved.
  if (options.managed == null) {
    options.managed = !!tasks;
  }
  if (options.parallel == null) {
    options.parallel = 1;
  }
  if (options.parallel === false) {
    options.parallel = 1;
  }
  if (options.parallel === true) {
    options.parallel = -1;
  }
  if (options.end == null) {
    options.end = true;
  }
  state = {
    stack: [],
    pause: options.pause != null ? !!options.pause : false,
    error: void 0,
    output: [],
    resolved: 0,
    fulfilled: 0,
    rejected: 0,
    pending: 0,
    managed: {
      running: 0,
      resolved: false
    },
    running: 0
  };
  count_pending_tasks = function() {
    return state.stack.filter(function(task) {
      return task.managed;
    }).length;
  };
  clear_managed_tasks = function() {
    return state.stack = state.stack.filter(function(task) {
      return !task.managed;
    });
  };
  promise = new Promise(function(resolve, reject) {
    scheduler = {
      state: state,
      end: function(end) {
        options.end = end;
        return scheduler.pump();
      },
      pump: function() {
        var task;
        if (state.pause) {
          return;
        }
        if (state.running === options.parallel) {
          return;
        }
        if (!state.managed.resolved) {
          if (state.managed.error) {
            state.managed.resolved = true;
            // Any pending managed task is stripped out after an error
            clear_managed_tasks();
            scheduler.pump();
            return reject(state.managed.error);
          } else if (options.managed && options.end && count_pending_tasks() + state.managed.running === 0) {
            state.managed.resolved = true;
            scheduler.pump();
            return resolve(state.output);
          } else if (!options.managed && options.end && state.stack.length === 0) {
            state.managed.resolved = true;
            return resolve();
          }
        }
        if (!state.stack.length) {
          return;
        }
        task = state.stack.shift();
        if (options.strict === true && !task.managed && state.error) {
          task.reject(state.error);
          setImmediate(scheduler.pump);
          return;
        }
        state.running++;
        state.pending--;
        if (task.managed) {
          state.managed.running++;
        }
        // A managed handler cannot be scheduled once the scheduler resolves
        if (task.managed && state.managed.resolved) {
          throw utils.error('SCHEDULER_RESOLVED', ['cannot execute a new handler,', 'scheduler already in resolved state.']);
        }
        return setImmediate(async function() {
          var error, result;
          try {
            result = (await task.handler.call());
            state.running--;
            if (task.managed) {
              state.managed.running--;
            }
            state.fulfilled++;
            state.resolved++;
            task.resolve.call(null, result);
            if (task.managed) {
              state.output.push(result);
            }
            return setImmediate(scheduler.pump);
          } catch (error1) {
            error = error1;
            state.running--;
            if (task.managed) {
              state.managed.running--;
            }
            state.rejected++;
            state.resolved++;
            task.reject.call(null, error);
            if (options.strict) {
              state.error = error;
            }
            if (task.managed) {
              state.managed.error = error;
            }
            return setImmediate(scheduler.pump);
          }
        });
      },
      unshift: function(tasks) {
        var isArray;
        isArray = Array.isArray(tasks);
        if (!isArray && typeof tasks === 'function') {
          tasks = {
            handler: tasks
          };
        }
        if (!(isArray || is_object_literal(tasks))) {
          throw Error('Invalid Argument');
        }
        return new Promise(function(resolve, reject) {
          var task;
          if (!isArray) {
            state.pending++;
            if (tasks.managed == null) {
              tasks.managed = options.managed;
            }
            state.stack.unshift({
              ...tasks,
              resolve: resolve,
              reject: reject
            });
            return scheduler.pump();
          } else {
            // Unshift from the last to the first element to preserve order
            return Promise.all(((function() {
              var i, len, ref, results;
              ref = tasks.reverse();
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                task = ref[i];
                results.push(scheduler.unshift(task));
              }
              return results;
            })()).reverse()).then(resolve, reject);
          }
        });
      },
      pause: function() {
        return state.pause = true;
      },
      broadcast: function(err, result) {
        // this is a terrible hack, see session/plugins/on_normalize
        // for a test illustrating it when an error is throw in parent
        // and children are still registered for execution
        options.strict = true; // and not task.managed and state.error
        state.pause = false;
        state.error = err;
        if (state.stack.length) {
          return scheduler.pump();
        }
      },
      resume: function() {
        if (!state.pause) {
          return;
        }
        state.pause = false;
        if (state.stack.length) {
          return scheduler.pump();
        }
      },
      push: function(tasks) {
        var isArray, prom;
        isArray = Array.isArray(tasks);
        if (!isArray && typeof tasks === 'function') {
          tasks = {
            handler: tasks
          };
        }
        if (!(isArray || is_object_literal(tasks))) {
          throw Error('Invalid Argument');
        }
        prom = new Promise(function(resolve, reject) {
          var task;
          if (!isArray) {
            state.pending++;
            if (tasks.managed == null) {
              tasks.managed = options.managed;
            }
            state.stack.push({
              ...tasks,
              resolve: resolve,
              reject: reject
            });
            return scheduler.pump();
          } else {
            return Promise.all((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = tasks.length; i < len; i++) {
                task = tasks[i];
                results.push(scheduler.push(task));
              }
              return results;
            })()).then(resolve, reject);
          }
        });
        prom.catch((function() {})); // Handle strict unhandled rejections
        return prom;
      }
    };
    if (tasks) {
      if (tasks.length) {
        return scheduler.push(tasks.map(function(task) {
          if (typeof task === 'function') {
            task = {
              handler: task
            };
          }
          return {
            managed: true,
            ...task
          };
        }));
      } else {
        return resolve([]);
      }
    }
  });
  promise.catch((function() {})); // Handle strict unhandled rejections
  return new Proxy(promise, {
    get: function(target, name) {
      if (target[name] != null) {
        if (typeof target[name] === 'function') {
          return target[name].bind(target);
        } else {
          return target[name];
        }
      } else {
        return scheduler[name];
      }
    }
  });
};
