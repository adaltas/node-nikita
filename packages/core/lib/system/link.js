// Generated by CoffeeScript 2.5.0
// # `nikita.system.link`

// Create a symbolic link and it's parent directories if they don't yet
// exist.

// Note, it is valid for the "source" file to not exist.

// ## Options

// * `source`   
//   Referenced file to be linked.   
// * `target`   
//   Symbolic link to be created.   
// * `exec`   
//   Create an executable file with an `exec` command.   
// * `mode`   
//   Default to `0o0755`.   

// ## Callback Parameters

// * `err`   
//   Error object if any.   
// * `status`   
//   Value is "true" if link was created or modified.   

// ## Example

// ```js
// require('nikita').system.link({
//   source: __dirname,
//   target: '/tmp/a_link'
// }, function(err, {status}){
//   console.info(err ? err.message : 'Link created: ' + status);
// });
// ```

// ## Source Code
var path;

module.exports = function({options}, callback) {
  var count, do_dispatch, do_end, do_mkdir, exec_create, exec_exists, sym_create, sym_exists;
  this.log({
    message: "Entering link",
    level: 'DEBUG',
    module: 'nikita/lib/system/link'
  });
  count = 0;
  sym_exists = (options, callback) => {
    return this.fs.readlink({
      target: options.target
    }, function(err, {target}) {
      if (err) {
        return callback(null, false);
      }
      if (target === options.source) {
        return callback(null, true);
      }
      return this.fs.unlink({
        target: options.target
      }, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null, false);
      });
    });
  };
  sym_create = (options, callback) => {
    return this.fs.symlink({
      source: options.source,
      target: options.target
    }, function(err) {
      if (err) {
        return callback(err);
      }
      count++;
      return callback();
    });
  };
  exec_exists = (options, callback) => {
    return this.fs.exists({
      target: options.target
    }, function(err, {exists}) {
      if (!exists) {
        return callback(null, false);
      }
      return this.fs.readFile({
        target: options.target,
        encoding: 'utf8'
      }, function(err, {data}) {
        var exec_cmd;
        if (err) {
          return callback(err);
        }
        exec_cmd = /exec (.*) \$@/.exec(data)[1];
        return callback(null, exec_cmd && exec_cmd === options.source);
      });
    });
  };
  exec_create = (options, callback) => {
    var content;
    content = `#!/bin/bash
exec ${options.source} $@`;
    return this.fs.writeFile({
      target: options.target,
      content: content
    }, function(err) {
      if (err) {
        return callback(err);
      }
      return this.fs.chmod({
        target: options.target,
        mode: options.mode
      }, function(err) {
        if (err) {
          return callback(err);
        }
        count++;
        return callback();
      });
    });
  };
  if (!options.source) {
    return callback(Error(`Missing source, got ${JSON.stringify(options.source)}`));
  }
  if (!options.target) {
    return callback(Error(`Missing target, got ${JSON.stringify(options.target)}`));
  }
  if (options.mode == null) {
    options.mode = 0o0755;
  }
  do_mkdir = () => {
    return this.system.mkdir({
      target: path.dirname(options.target)
    }, function(err, created) {
      if (err && err.code !== 'EEXIST') {
        // It is possible to have collision if to symlink
        // have the same parent directory
        return callback(err);
      }
      return do_dispatch();
    });
  };
  do_dispatch = () => {
    if (options.exec) {
      return exec_exists(options, function(err, exists) {
        if (exists) {
          return do_end();
        }
        return exec_create(options, do_end);
      });
    } else {
      return sym_exists(options, function(err, exists) {
        if (exists) {
          return do_end();
        }
        return sym_create(options, do_end);
      });
    }
  };
  do_end = function() {
    return callback(null, {
      status: !!count,
      count: count
    });
  };
  return do_mkdir();
};

// ## Dependencies
path = require('path');
