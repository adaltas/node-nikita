// Generated by CoffeeScript 2.4.1
// # `nikita.file.properties`

// Write a file in the Java properties format.

// ## Options

// * `backup` (string|boolean)   
//   Create a backup, append a provided string to the filename extension or a
//   timestamp if value is not a string, only apply if the target file exists and
//   is modified.
// * `comment` (boolean)   
//   Preserve comments.
// * `content` (object)   
//   List of properties to write.
// * `local` (boolean)   
//   Treat the source as local instead of remote, only apply with "ssh"
//   option.
// * `sort` (boolean)   
//   Sort the properties before writting them. False by default.
// * `target` (string)   
//   File path where to write content to.
// * `trim` (boolean)   
//   Trim keys and value.
// * `merge` (boolean)   
//   Merges content properties with target file. False by default
// * `separator` (string)   
//   The caracter to use for separating property and value. '=' by default.

// ## Exemple

// Use a custom delimiter with spaces around the equal sign.

// ```javascript
// require('nikita')
// .file.properties({
//   target: "/path/to/target.json",
//   content: { key: "value" },
//   separator: ' = '
//   merge: true
// })
// ```

// ## Source Code
module.exports = function({options}) {
  var fnl_props, k, org_props, ref, v;
  this.log({
    message: "Entering file.properties",
    level: 'DEBUG',
    module: 'nikita/lib/file/properties'
  });
  if (!options.target) {
    // Options
    throw Error("Missing argument options.target");
  }
  if (options.separator == null) {
    options.separator = '=';
  }
  if (options.content == null) {
    options.content = {};
  }
  if (options.sort == null) {
    options.sort = false;
  }
  // Trim
  if (!options.trim) {
    fnl_props = options.content;
  } else {
    fnl_props = {};
    ref = options.content;
    for (k in ref) {
      v = ref[k];
      k = k.trim();
      if (typeof v === 'string') {
        v = v.trim();
      }
      fnl_props[k] = v;
    }
  }
  org_props = {};
  this.log({
    message: `Merging "${(options.merge ? 'true' : 'false')}"`,
    level: 'DEBUG',
    module: 'nikita/lib/file/properties'
  });
  // Read Original
  this.file.properties.read({
    if_exists: true,
    target: options.target,
    separator: options.separator,
    comment: options.comment,
    trim: options.trim
  }, function(err, {properties}) {
    if (!err) {
      return org_props = properties || {};
    }
  });
  // Diff
  this.call(function({}, callback) {
    var i, j, key, keys, l, len, len1, len2, ref1, ref2, ref3, status;
    status = false;
    keys = {};
    ref1 = Object.keys(org_props);
    for (i = 0, len = ref1.length; i < len; i++) {
      k = ref1[i];
      keys[k] = true;
    }
    ref2 = Object.keys(fnl_props);
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      k = ref2[j];
      keys[k] = true;
    }
    ref3 = Object.keys(keys);
    for (l = 0, len2 = ref3.length; l < len2; l++) {
      key = ref3[l];
      if (`${org_props[key]}` !== `${fnl_props[key]}`) {
        this.log({
          message: `Property '${key}' was '${org_props[k]}' and is now '${fnl_props[k]}'`,
          level: 'WARN',
          module: 'ryba/lib/file/properties'
        });
        if (fnl_props[key] != null) {
          status = true;
        }
      }
    }
    return callback(null, status);
  });
  // Merge
  this.call({
    if: options.merge
  }, function() {
    for (k in fnl_props) {
      v = fnl_props[k];
      org_props[k] = fnl_props[k];
    }
    return fnl_props = org_props;
  });
  return this.call(function() {
    var data, key, keys;
    // Write data
    keys = options.sort ? Object.keys(fnl_props).sort() : Object.keys(fnl_props);
    data = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (fnl_props[key] != null) {
          results.push(`${key}${options.separator}${fnl_props[key]}`);
        } else {
          results.push(`${key // This is a comment
}`);
        }
      }
      return results;
    })();
    this.file({
      target: `${options.target}`,
      content: data.join('\n'),
      backup: options.backup,
      eof: true,
      shy: true
    });
    this.system.chown({
      target: options.target,
      uid: options.uid,
      gid: options.gid,
      if: (options.uid != null) || (options.gid != null)
    });
    return this.system.chmod({
      target: options.target,
      mode: options.mode,
      if: options.mode != null
    });
  });
};
