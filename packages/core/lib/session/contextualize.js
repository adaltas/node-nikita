// Generated by CoffeeScript 2.7.0
var indexOf = [].indexOf;

const {mutate, is_object_literal} = require('mixme');
const utils = require('../utils');

const properties = [
  'context', 'handler', 'hooks', 'metadata',
  'config', 'parent', 'plugins', 'registry', 
  'run', 'scheduler', 'ssh', 'state'
];

module.exports = function(args) {
  // Reconstituate the action
  const default_action = () => ({
    config: {},
    metadata: {},
    hooks: {},
    state: {}
  });
  const new_action = default_action();
  for (const arg of args) {
    switch (typeof arg) {
      case 'function':
        if (new_action.handler) {
          throw utils.error('NIKITA_SESSION_INVALID_ARGUMENTS', [`handler is already registered, got ${utils.error.got(arg)}`]);
        }
        mutate(new_action, {
          handler: arg
        });
        break;
      case 'string':
        if (new_action.handler) {
          throw utils.error('NIKITA_SESSION_INVALID_ARGUMENTS', [`handler is already registered, got ${JSON.stringigy(arg)}`]);
        }
        mutate(new_action, {
          metadata: {
            argument: arg
          }
        });
        break;
      case 'object':
        if (Array.isArray(arg)) {
          throw utils.error('NIKITA_SESSION_INVALID_ARGUMENTS', [`argument cannot be an array, got ${utils.error.got(arg)}`]);
        }
        if (arg === null) {
          mutate(new_action, {
            metadata: {
              argument: null
            }
          });
        } else if (is_object_literal(arg)) {
          for (const k in arg) {
            const v = arg[k];
            if (k === '$') {
              // mutate new_action, v
              for (const kk in v) {
                const vv = v[kk];
                if (['config', 'metadata'].includes(kk)) {
                  new_action[kk] = {...new_action[kk], ...vv};
                } else {
                  new_action[kk] = vv;
                }
              }
            } else if (k[0] === '$') {
              if (k === '$$') {
                mutate(new_action.metadata, v);
              } else {
                prop = k.substr(1);
                if (indexOf.call(properties, prop) >= 0) {
                  new_action[prop] = v;
                } else {
                  new_action.metadata[prop] = v;
                }
              }
            } else {
              if (v !== undefined) {
                new_action.config[k] = v;
              }
            }
          }
        } else {
          mutate(new_action, {
            metadata: {
              argument: arg
            }
          });
        }
        break;
      default:
        mutate(new_action, {
          metadata: {
            argument: arg
          }
        });
    }
  }
  // Create empty action when no arguments are provided and not for an empty array
  // new_actions = default_action() if not args.length
  return new_action;
};
