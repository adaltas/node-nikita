// Generated by CoffeeScript 2.6.1
/*
The plugin enrich the config object with default values defined in the JSON
schema. Thus, it mst be defined after every module which modify the config
object.
*/
var Ajv, ajv_formats, ajv_keywords, instanceofDef, merge, mutate, parse, stream, utils;

stream = require('stream');

({merge, mutate} = require('mixme'));

Ajv = require('ajv').default;

ajv_keywords = require('ajv-keywords');

ajv_formats = require("ajv-formats");

utils = require('../../utils');

instanceofDef = require('ajv-keywords/dist/definitions/instanceof');

instanceofDef.CONSTRUCTORS['Error'] = Error;

instanceofDef.CONSTRUCTORS['stream.Writable'] = stream.Writable;

instanceofDef.CONSTRUCTORS['stream.Readable'] = stream.Readable;

parse = function(uri) {
  var matches;
  matches = /^(\w+:)\/\/(.*)/.exec(uri);
  if (!matches) {
    throw utils.error('NIKITA_SCHEMA_MALFORMED_URI', ['uri must start with a valid protocol', 'such as "module://" or "registry://",', `got ${JSON.stringify(uri)}.`]);
  }
  return {
    protocol: matches[1],
    pathname: matches[2]
  };
};

module.exports = {
  name: '@nikitajs/core/lib/plugins/tools/schema',
  hooks: {
    'nikita:normalize': {
      handler: async function(action) {
        var ajv, ref;
        // Handler execution
        // action = await handler.apply null, arguments
        if (action.tools == null) {
          action.tools = {};
        }
        // Get schema from parent action
        if ((ref = action.parent) != null ? ref.tools.schema : void 0) {
          action.tools.schema = action.parent.tools.schema;
          return action;
        }
        // Instantiate a new schema
        ajv = new Ajv({
          $data: true,
          allErrors: true,
          useDefaults: true,
          allowUnionTypes: true, // eg type: ['boolean', 'integer']
          strict: true,
          strictRequired: false, // see https://github.com/ajv-validator/ajv/issues/1571
          coerceTypes: 'array',
          loadSchema: function(uri) {
            return new Promise(async function(accept, reject) {
              var err, module, pathname, protocol;
              try {
                ({protocol, pathname} = parse(uri));
              } catch (error) {
                err = error;
                return reject(err);
              }
              switch (protocol) {
                case 'module:':
                  try {
                    action = require.main.require(pathname);
                    return accept({
                      definitions: action.metadata.definitions
                    });
                  } catch (error) {
                    err = error;
                    return reject(utils.error('NIKITA_SCHEMA_INVALID_MODULE', ['the module location is not resolvable,', `module name is ${JSON.stringify(pathname)}.`]));
                  }
                  break;
                case 'registry:':
                  module = pathname.split('/');
                  action = (await action.registry.get(module));
                  if (action) {
                    return accept({
                      definitions: action.metadata.definitions
                    });
                  } else {
                    return reject(utils.error('NIKITA_SCHEMA_UNREGISTERED_ACTION', ['the action is not registered inside the Nikita registry,', `action namespace is ${JSON.stringify(module.join('.'))}.`]));
                  }
                  break;
                default:
                  return reject(utils.error('NIKITA_SCHEMA_UNSUPPORTED_PROTOCOL', ['the $ref instruction reference an unsupported protocol,', `got ${JSON.stringify(protocol)}.`]));
              }
            });
          }
        });
        ajv_keywords(ajv);
        ajv_formats(ajv);
        ajv.addKeyword({
          keyword: "filemode",
          type: ['integer', 'string'],
          compile: function(value) {
            return function(data, schema, parentData) {
              if (typeof data === 'string' && /^\d+$/.test(data)) {
                schema.parentData[schema.parentDataProperty] = parseInt(data, 8);
              }
              return true;
            };
          },
          metaSchema: {
            type: 'boolean',
            enum: [true]
          }
        });
        action.tools.schema = {
          ajv: ajv,
          add: function(schema, name) {
            if (!schema) {
              return;
            }
            return ajv.addSchema(schema, name);
          },
          addMetadata: function(name, future) {
            var current, schema;
            schema = ajv.getSchema('nikita').schema;
            current = schema.definitions.metadata.properties[name];
            if (utils.object.match(current, future)) {
              return false;
            }
            ajv.removeSchema('nikita');
            schema = merge(schema, {
              definitions: {
                metadata: {
                  properties: {
                    [name]: future
                  }
                }
              }
            });
            ajv.addSchema(schema, 'nikita');
            return true;
          },
          validate: async function(action, schema) {
            var err, validate;
            try {
              if (schema == null) {
                schema = action.metadata.definitions;
              }
              schema = {
                definitions: schema,
                type: 'object',
                allOf: [
                  {
                    properties: (function(obj = {}) {
                      var k,
                  v;
                      for (k in schema) {
                        v = schema[k];
                        obj[k] = {
                          $ref: `#/definitions/${k}`
                        };
                      }
                      return obj;
                    })()
                  },
                  {
                    properties: {
                      metadata: {
                        $ref: 'nikita#/definitions/metadata'
                      }
                    }
                  }
                ]
              };
              validate = (await ajv.compileAsync(schema));
            } catch (error) {
              err = error;
              if (!err.code) {
                err.code = 'NIKITA_SCHEMA_INVALID_DEFINITION';
                err.message = `${err.code}: ${err.message}`;
              }
              throw err;
            }
            if (validate(utils.object.filter(action, ['error', 'output']))) {
              return;
            }
            return utils.error('NIKITA_SCHEMA_VALIDATION_CONFIG', [
              validate.errors.length === 1 ? 'one error was found in the configuration of ' : 'multiple errors were found in the configuration of ',
              action.metadata.namespace.length ? `action \`${action.metadata.namespace.join('.')}\`` : "root action",
              action.metadata.namespace.join('.') === 'call' && action.metadata.module !== '@nikitajs/core/lib/actions/call' ? ` in module ${action.metadata.module}` : void 0,
              ':',
              validate.errors.map(function(err) {
                var key,
              msg,
              value;
                msg = ' ' + err.schemaPath + ' ' + ajv.errorsText([err]).replace(/^data\//,
              '');
                if (err.params) {
                  msg += ((function() {
                    var ref1,
              results;
                    ref1 = err.params;
                    results = [];
                    for (key in ref1) {
                      value = ref1[key];
                      if (key === 'missingProperty') {
                        continue;
                      }
                      results.push(`, ${key} is ${JSON.stringify(value)}`);
                    }
                    return results;
                  })()).join('');
                }
                return msg;
              }).sort().join(';')
            ].join('') + '.');
          }
        };
        await action.plugins.call({
          name: 'nikita:schema',
          args: {
            action: action,
            ajv: ajv,
            schema: {
              definitions: {
                metadata: {
                  type: 'object',
                  properties: {}
                },
                tools: {
                  type: 'object',
                  properties: {}
                }
              }
            }
          },
          // TODO: write a test and document before activation
          // hooks: action.hooks['nikita:schema']
          handler: function({action, ajv, schema}) {
            return ajv.addSchema(schema, 'nikita');
          }
        });
        return action;
      }
    },
    'nikita:schema': function({schema}) {
      return mutate(schema.definitions.metadata.properties, {
        schema: {
          type: 'boolean',
          default: true,
          description: `Set to \`false\` to disable schema validation in the
current action.`
        }
      });
    }
  }
};
