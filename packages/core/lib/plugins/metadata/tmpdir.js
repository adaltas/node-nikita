// Generated by CoffeeScript 2.6.1
// {is_object, is_object_literal} = require 'mixme'
var exec, fs, os, process, utils;

utils = require('../../utils');

os = require('os');

process = require('process');

fs = require('ssh2-fs');

exec = require('ssh2-exec');

module.exports = {
  name: '@nikitajs/core/lib/plugins/metadata/tmpdir',
  require: ['@nikitajs/core/lib/plugins/tools/find', '@nikitajs/core/lib/plugins/tools/path'],
  hooks: {
    'nikita:action': {
      after: ['@nikitajs/core/lib/plugins/ssh', '@nikitajs/core/lib/plugins/tools/path', '@nikitajs/core/lib/plugins/metadata/uuid'],
      handler: async function(action) {
        var config, err, metadata, os_tmpdir, ref, ssh, tmpDirInParent, tools;
        ({config, metadata, tools} = action);
        if ((ref = typeof metadata.tmpdir) !== 'boolean' && ref !== 'function' && ref !== 'string' && ref !== 'undefined') {
          throw utils.error('METADATA_TMPDIR_INVALID', ['the "tmpdir" metadata value must be a boolean, a function or a string,', `got ${JSON.stringify(metadata.tmpdir)}`]);
        }
        if (!metadata.tmpdir) {
          return;
        }
        // SSH connection extraction
        ssh = config.ssh === false ? void 0 : (await tools.find(function(action) {
          return action.ssh;
        }));
        // tmpdir = if ssh then '/tmp' else os.tmpdir()
        // Generate temporary location
        os_tmpdir = ssh ? '/tmp' : os.tmpdir();
        metadata.tmpdir = (await (async function() {
          switch (typeof metadata.tmpdir) {
            case 'string':
              return tools.path.resolve(os_tmpdir, metadata.tmpdir);
            case 'boolean':
              return tools.path.resolve(os_tmpdir, 'nikita-' + metadata.uuid);
            case 'function':
              return metadata.tmpdir = (await metadata.tmpdir.call(null, {
                action: action,
                os_tmpdir: os_tmpdir,
                tmpdir: 'nikita-' + metadata.uuid
              }));
          }
        })());
        // Temporary directory creation
        tmpDirInParent = action.parent && (await tools.find(action.parent, function(parent) {
          if (parent.metadata.tmpdir === metadata.tmpdir) {
            return true;
          }
          return void 0;
        }));
        if (tmpDirInParent) {
          return;
        }
        try {
          await fs.mkdir(ssh, metadata.tmpdir);
          return metadata.tmpdir_dispose = true;
        } catch (error) {
          err = error;
          if (err.code !== 'EEXIST') {
            throw err;
          }
        }
      }
    },
    'nikita:result': {
      before: '@nikitajs/core/lib/plugins/ssh',
      handler: async function({action}) {
        var config, metadata, ssh, tools;
        ({config, metadata, tools} = action);
        // Value of tmpdir could still be true if there was an error in
        // one of the on_action hook, such as a invalid schema validation
        if (typeof metadata.tmpdir !== 'string') {
          return;
        }
        if (!metadata.tmpdir_dispose) {
          return;
        }
        if (metadata.dirty) {
          return;
        }
        // SSH connection extraction
        ssh = config.ssh === false ? void 0 : (await tools.find(action, function(action) {
          return action.ssh;
        }));
        // Temporary directory decommissioning
        return (await new Promise(function(resolve, reject) {
          return exec(ssh, `rm -r '${metadata.tmpdir}'`, function(err) {
            if (err) {
              return reject(err);
            } else {
              return resolve();
            }
          });
        }));
      }
    }
  }
};
