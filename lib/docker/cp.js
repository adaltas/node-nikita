// Generated by CoffeeScript 2.3.1
// # `nikita.docker.cp(options, [callback])`

// Copy files/folders between a container and the local filesystem.

// Reflecting the original docker ps command usage, source and target may take
// the following forms:

// * CONTAINER:PATH 
// * LOCALPATH
// * process.readableStream as the source or process.writableStream as the
//   target (equivalent of "-")

// Note, stream are not yet supported.

// ## Options

// * `boot2docker` (boolean)   
//   Whether to use boot2docker or not, default to false.
// * `machine` (string)   
//   Name of the docker-machine, required if using docker-machine or boot2docker.
// * `source` (string)   
//   The path to upload or the container followed by the path to download.
// * `target` (string)   
//   The path to download or the container followed by the path to upload.

// ## Uploading a file

// ```javascript
// nikita.docker({
//   source: readable_stream or '/path/to/source'
//   target: 'my_container:/path/to/target'
// }, function(err, status){})
// ```

// ## Downloading a file

// ```javascript
// nikita.docker({
//   source: 'my_container:/path/to/source',
//   target: writable_stream or '/path/to/target'
// }, function(err, status){
//   console.log( err ? err.message : 'Container copied: ' + status);
// });
// ```

// ## Source Code
var docker, path;

module.exports = function(options) {
  var _, k, ref, source_container, source_mkdir, source_path, ssh, target_container, target_mkdir, target_path, v;
  this.log({
    message: "Entering Docker cp",
    level: 'DEBUG',
    module: 'nikita/lib/docker/cp'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  // Global options
  if (options.docker == null) {
    options.docker = {};
  }
  ref = options.docker;
  for (k in ref) {
    v = ref[k];
    if (options[k] == null) {
      options[k] = v;
    }
  }
  if (!options.source) {
    // Validate parameters
    throw Error('Missing option "source"');
  }
  if (!options.target) {
    throw Error('Missing option "target"');
  }
  [_, source_container, source_path] = /(.*:)?(.*)/.exec(options.source);
  [_, target_container, target_path] = /(.*:)?(.*)/.exec(options.target);
  if (source_container && target_container) {
    throw Error('Incompatible source and target options');
  }
  if (!source_container && !target_container) {
    throw Error('Incompatible source and target options');
  }
  source_mkdir = false;
  target_mkdir = false;
  // Source is on the host, normalize path
  this.call(function(_, next) {
    if (source_container) {
      return next();
    }
    if (/\/$/.test(source_path)) {
      source_path = `${source_path}/${path.basename(target_path)}`;
      return next();
    }
    return this.fs.stat({
      ssh: options.ssh,
      target: source_path
    }, function(err, stat) {
      if (err && err.code !== 'ENOENT') {
        return next(err);
      }
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        // TODO wdavidw: seems like a mistake to me, we shall have source_mkdir instead
        return target_mkdir = true && next();
      }
      if (stat.isDirectory()) {
        source_path = `${source_path}/${path.basename(target_path)}`;
      }
      return next();
    });
  });
  this.system.mkdir({
    target: source_path,
    if: function() {
      return source_mkdir;
    }
  });
  // Destination is on the host
  this.call(function(_, next) {
    if (target_container) {
      return next();
    }
    if (/\/$/.test(target_path)) {
      target_path = `${target_path}/${path.basename(target_path)}`;
      return next();
    }
    return this.fs.stat({
      ssh: options.ssh,
      target: target_path
    }, function(err, stat) {
      if (err && err.code !== 'ENOENT') {
        return next(err);
      }
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return target_mkdir = true && next();
      }
      if (stat.isDirectory()) {
        target_path = `${target_path}/${path.basename(target_path)}`;
      }
      return next();
    });
  });
  this.system.mkdir({
    target: target_path,
    if: function() {
      return target_mkdir;
    }
  });
  return this.system.execute({
    cmd: docker.wrap(options, `cp ${options.source} ${options.target}`)
  }, docker.callback);
};

// ## Modules Dependencies
path = require('path');

docker = require('../misc/docker');
