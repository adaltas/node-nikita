// Generated by CoffeeScript 2.3.1
// # `nikita.ldap.acl(options, [goptions], callback)`

// Create new [ACLs](acls) for the OpenLDAP server.   

// This implementation currently doesn't execute remote SSH commands. Instead, it
// connects directly to the LDAP database and thus requires a specific port to be
// accessible.   

// ## Options

// *   `to`   
//     What to control access to as a string.   
// *   `by`   
//     Who to grant access to and the access to grant as an array
//     (eg: `{..., by:["ssf=64 anonymous auth"]}`).   
// *   `url`   
//     Specify URI referring to the ldap server, alternative to providing an
//     [ldapjs client] instance.   
// *   `binddn`   
//     Distinguished Name to bind to the LDAP directory, alternative to providing
//     an [ldapjs client] instance.   
// *   `passwd`   
//     Password for simple authentication, alternative to providing an
//     [ldapjs client] instance.   
// *   `ldap`   
//     Instance of an [ldapjs client][ldapclt], alternative to providing the `url`,
//     `binddn` and `passwd` connection properties.   
// *   `unbind`   
//     Close the ldap connection, default to false if connection is an
//     [ldapjs client][ldapclt] instance.   
// *   `name`   
//     Distinguish name storing the "olcAccess" property, using the database adress
//     (eg: "olcDatabase={2}bdb,cn=config").   
// *   `overwrite`   
//     Overwrite existing "olcAccess", default is to merge.   
// *   `log`   
//     Function called with a log related messages.   
// *   `acl`   
//     In case of multiple acls, regroup "before", "to" and "by" as an array.   

// ## Example

// ```js
// require('nikita/alt/ldap.acl')({
//   url: 'ldap://openldap.server/',
//   binddn: 'cn=admin,cn=config',
//   passwd: 'password',
//   name: 'olcDatabase={2}bdb,cn=config',
//   acls: [{
//     before: 'dn.subtree="dc=domain,dc=com"',
//     to: 'dn.subtree="ou=users,dc=domain,dc=com"',
//     by: [
//       'dn.exact="ou=users,dc=domain,dc=com" write',
//       "dn.base='gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth' read",
//       "* none"
//     ]
//   },{
//     to: 'dn.subtree="dc=domain,dc=com"',
//     by: [
//       'dn.exact="ou=kerberos,dc=domain,dc=com" write'
//     ]
//   }]
// }, function(err, modified){
//   console.log(err ? err.message : "ACL modified: " + !!modified);
// });
// ```
var each, wrap;

module.exports = function(goptions, options, callback) {
  var updated;
  if (options.acls == null) {
    options.acls = [{}];
  }
  updated = false;
  return each(options.acls).call(function(acl, next) {
    var b, client, connect, do_diff, end, i, j, len, parse, ref, save, search, stringify, unbind;
    if (acl.before == null) {
      acl.before = options.before;
    }
    if (acl.to == null) {
      acl.to = options.to;
    }
    if (acl.by == null) {
      acl.by = options.by;
    }
    client = null;
    acl.to = acl.to.trim();
    ref = acl.by;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      b = ref[i];
      acl.by[i] = b.trim();
    }
    connect = () => {
      var ref1, ref2, ref3;
      // if options.ldap instanceof ldap.client
      if (((ref1 = options.ldap) != null ? (ref2 = ref1.url) != null ? (ref3 = ref2.protocol) != null ? ref3.indexOf('ldap') : void 0 : void 0 : void 0) === 0) {
        client = options.ldap;
        return search();
      }
      this.log('Open and bind connection');
      client = ldap.createClient({
        url: options.url
      });
      return client.bind(options.binddn, options.passwd, function(err) {
        if (err) {
          return end(err);
        }
        return search();
      });
    };
    search = () => {
      this.log('Search attribute olcAccess');
      return client.search(options.name, {
        scope: 'base',
        attributes: ['olcAccess']
      }, (err, search) => {
        var olcAccess;
        if (err) {
          return unbind(err);
        }
        olcAccess = null;
        search.on('searchEntry', (entry) => {
          this.log(`Found ${JSON.stringify(entry.object)}`);
          // typeof olcAccess may be undefined, array or string
          olcAccess = entry.object.olcAccess || [];
          if (!Array.isArray(olcAccess)) {
            return olcAccess = [olcAccess];
          }
        });
        return search.on('end', () => {
          this.log(`Attribute olcAccess was ${JSON.stringify(olcAccess)}`);
          return parse(olcAccess);
        });
      });
    };
    parse = function(_olcAccess) {
      var access, buf, buftype, bys, c, k, l, len1, len2, matches, olcAccess, to;
      olcAccess = [];
      for (i = k = 0, len1 = _olcAccess.length; k < len1; i = ++k) {
        access = _olcAccess[i];
        to = '';
        bys = [];
        buftype = 0; // 0: start, 1: to, 2:by
        buf = '';
        for (i = l = 0, len2 = access.length; l < len2; i = ++l) {
          c = access[i];
          buf += c;
          if (buftype === 0) {
            if (/to$/.test(buf)) {
              buf = '';
              buftype = 1;
            }
          }
          if (buftype === 1) {
            if (matches = /^(.*)by$/.exec(buf)) {
              to = matches[1].trim();
              buf = '';
              buftype = 2;
            }
          }
          if (buftype === 2) {
            if (matches = /^(.*)by$/.exec(buf)) {
              bys.push(matches[1].trim());
              buf = '';
            } else if (i + 1 === access.length) {
              bys.push(buf.trim());
            }
          }
        }
        olcAccess.push({
          to: to,
          by: bys
        });
      }
      return do_diff(olcAccess);
    };
    do_diff = function(olcAccess) {
      var aby, access, fby, found, k, l, len1, len2, len3, len4, len5, m, n, o, oby, ref1, ref2, toAlreadyExist;
      toAlreadyExist = false;
      for (i = k = 0, len1 = olcAccess.length; k < len1; i = ++k) {
        access = olcAccess[i];
        if (acl.to !== access.to) {
          continue;
        }
        toAlreadyExist = true;
        fby = !options.overwrite ? access.by : [];
        ref1 = acl.by;
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          oby = ref1[l];
          found = false;
          ref2 = access.by;
          for (m = 0, len3 = ref2.length; m < len3; m++) {
            aby = ref2[m];
            if (oby === aby) {
              found = true;
              break;
            }
          }
          if (!found) {
            updated = true;
            fby.push(oby);
          }
        }
        olcAccess[i].by = fby;
      }
      if (!toAlreadyExist) {
        updated = true;
        // place before
        if (acl.before) {
          found = null;
          for (i = n = 0, len4 = olcAccess.length; n < len4; i = ++n) {
            access = olcAccess[i];
            if (access.to === acl.before) {
              found = i;
            }
          }
          // throw Error 'Before does not match any "to" rule' unless found?
          olcAccess.splice(found - 1, 0, {
            to: acl.to,
            by: acl.by
          });
        // place after
        } else if (acl.after) {
          found = false;
          for (i = o = 0, len5 = olcAccess.length; o < len5; i = ++o) {
            access = olcAccess[i];
            if (access.to === options.after) {
              found = i;
            }
          }
          // throw Error 'After does not match any "to" rule'
          olcAccess.splice(found, 0, {
            to: acl.to,
            by: acl.by
          });
        } else {
          // append
          olcAccess.push({
            to: acl.to,
            by: acl.by
          });
        }
      }
      if (updated) {
        return stringify(olcAccess);
      } else {
        return unbind();
      }
    };
    stringify = function(olcAccess) {
      var access, bie, k, l, len1, len2, ref1, value;
      for (i = k = 0, len1 = olcAccess.length; k < len1; i = ++k) {
        access = olcAccess[i];
        value = `{${i}}to ${access.to}`;
        ref1 = access.by;
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          bie = ref1[l];
          value += ` by ${bie}`;
        }
        olcAccess[i] = value;
      }
      return save(olcAccess);
    };
    save = function(olcAccess) {
      var change;
      change = new ldap.Change({
        operation: 'replace',
        modification: {
          olcAccess: olcAccess
        }
      });
      return client.modify(options.name, change, function(err) {
        return unbind(err);
      });
    };
    unbind = (err) => {
      var ref1, ref2, ref3;
      this.log('Unbind connection');
      if (((ref1 = options.ldap) != null ? (ref2 = ref1.url) != null ? (ref3 = ref2.protocol) != null ? ref3.indexOf('ldap') : void 0 : void 0 : void 0) === 0 && !options.unbind) {
        // return end err if options.ldap instanceof ldap.client and not options.unbind
        return end(err);
      }
      return client.unbind(function(e) {
        if (e) {
          return next(e);
        }
        return end(err);
      });
    };
    end = function(err) {
      return next(err);
    };
    return connect();
  }).next(function(err) {
    return next(err, updated);
  });
};

// ## Dependencies
each = require('each');

wrap = require('../misc/wrap');

// [acls]: http://www.openldap.org/doc/admin24/access-control.html
// [ldapclt]: http://ldapjs.org/client.html
