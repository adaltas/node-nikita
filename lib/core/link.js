// Generated by CoffeeScript 1.11.1
var fs, path;

module.exports = function(options, callback) {
  var do_dispatch, do_end, do_mkdir, exec_create, exec_exists, linked, sym_create, sym_exists;
  options.log({
    message: "Entering link",
    level: 'DEBUG',
    module: 'mecano/lib/link'
  });
  linked = 0;
  sym_exists = function(options, callback) {
    return fs.readlink(options.ssh, options.target, function(err, resolvedPath) {
      if (err) {
        return callback(null, false);
      }
      if (resolvedPath === options.source) {
        return callback(null, true);
      }
      return fs.unlink(options.ssh, options.target, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null, false);
      });
    });
  };
  sym_create = function(options, callback) {
    return fs.symlink(options.ssh, options.source, options.target, function(err) {
      if (err) {
        return callback(err);
      }
      linked++;
      return callback();
    });
  };
  exec_exists = function(options, callback) {
    return fs.exists(options.ssh, options.target, function(err, exists) {
      if (!exists) {
        return callback(null, false);
      }
      return fs.readFile(options.ssh, options.target, 'utf8', function(err, content) {
        var exec_cmd;
        if (err) {
          return callback(err);
        }
        exec_cmd = /exec (.*) \$@/.exec(content)[1];
        return callback(null, exec_cmd && exec_cmd === options.source);
      });
    });
  };
  exec_create = function(options, callback) {
    var content;
    content = "#!/bin/bash\nexec " + options.source + " $@";
    return fs.writeFile(options.ssh, options.target, content, function(err) {
      if (err) {
        return callback(err);
      }
      return fs.chmod(options.ssh, options.target, options.mode, function(err) {
        if (err) {
          return callback(err);
        }
        linked++;
        return callback();
      });
    });
  };
  if (!options.source) {
    return callback(new Error("Missing source, got " + (JSON.stringify(options.source))));
  }
  if (!options.target) {
    return callback(new Error("Missing target, got " + (JSON.stringify(options.target))));
  }
  if (options.mode == null) {
    options.mode = 0x1ed;
  }
  do_mkdir = (function(_this) {
    return function() {
      return _this.system.mkdir({
        ssh: options.ssh,
        target: path.dirname(options.target)
      }, function(err, created) {
        if (err && err.code !== 'EEXIST') {
          return callback(err);
        }
        return do_dispatch();
      });
    };
  })(this);
  do_dispatch = function() {
    if (options.exec) {
      return exec_exists(options, function(err, exists) {
        if (exists) {
          return do_end();
        }
        return exec_create(options, do_end);
      });
    } else {
      return sym_exists(options, function(err, exists) {
        if (exists) {
          return do_end();
        }
        return sym_create(options, do_end);
      });
    }
  };
  do_end = function() {
    return callback(null, linked);
  };
  return do_mkdir();
};

fs = require('ssh2-fs');

path = require('path');
