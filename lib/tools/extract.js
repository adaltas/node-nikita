// Generated by CoffeeScript 2.3.1
// # `nikita.tools.extract`

// Extract an archive. Multiple compression types are supported. Unless
// specified as an option, format is derived from the source extension. At the
// moment, supported extensions are '.tgz', '.tar.gz', tar.bz2, 'tar.xz' and '.zip'.

// ## Options

// * `creates`   
//   Ensure the given file is created or an error is send in the callback.  
// * `format`   
//   One of 'tgz', 'tar', 'xz', 'bz2' or 'zip'.   
// * `preserve_owner`   
//   Preserve ownership when extracting. True by default if runned as root, else false.   
// * `preserve_permissions`   
//   Preserve permissions when extracting. True by default if runned as root, else false.   
// * `source`   
//   Archive to decompress.   
// * `strip`   
//   Remove the specified number of leading path elements. Apply only to tar(s) formats.   
// * `target`   
//   Default to the source parent directory.   

// ## Callback parameters

// * `err`   
//   Error object if any.   
// * `extracted`   
//   Value is "true" if archive was extracted.   

// ## Example

// ```javascript
// require('nikita').tools.extract({
//   source: '/path/to/file.tgz'
//   destation: '/tmp'
// }, function(err, status){
//   console.log(err ? err.message : 'File was extracted: ' + status);
// });
// ```

// ## Source Code
var misc, path;

module.exports = function(options, callback) {
  var creates, ext, extract, format, ref, ssh, stat, success, tar_opts, target;
  this.log({
    message: "Entering extract",
    level: 'DEBUG',
    module: 'nikita/lib/tools/extract'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  if (!options.source) {
    // Validate options
    return callback(Error(`Missing source: ${options.source}`));
  }
  target = (ref = options.target) != null ? ref : path.dirname(options.source);
  tar_opts = [];
  // If undefined, we do not apply flag. Default behaviour depends on the user
  if (options.preserve_owner === true) {
    tar_opts.push('--same-owner');
  } else if (options.preserve_owner === false) {
    tar_opts.push('--no-same-owner');
  }
  if (options.preserve_permissions === true) {
    tar_opts.push('-p');
  } else if (options.preserve_permissions === false) {
    tar_opts.push('--no-same-permissions');
  }
  if (typeof options.strip === 'number') {
    tar_opts.push(`--strip-components ${options.strip}`);
  }
  // Deal with format option
  if (options.format != null) {
    format = options.format;
  } else {
    if (/\.(tar\.gz|tgz)$/.test(options.source)) {
      format = 'tgz';
    } else if (/\.tar$/.test(options.source)) {
      format = 'tar';
    } else if (/\.zip$/.test(options.source)) {
      format = 'zip';
    } else if (/\.tar\.bz2$/.test(options.source)) {
      format = 'bz2';
    } else if (/\.tar\.xz$/.test(options.source)) {
      format = 'xz';
    } else {
      ext = path.extname(options.source);
      return callback(Error(`Unsupported extension, got ${JSON.stringify(ext)}`));
    }
  }
  // Start real work
  stat = () => {
    return this.fs.stat({
      ssh: options.ssh,
      target: options.source
    }, function(err, {stats}) {
      if (err) {
        return callback(Error(`File does not exist: ${options.source}`));
      }
      if (!misc.stats.isFile(stats.mode)) {
        return callback(Error(`Not a File: ${options.source}`));
      }
      return extract();
    });
  };
  extract = () => {
    var cmd;
    cmd = null;
    this.log({
      message: `Format is ${format}`,
      level: 'DEBUG',
      module: 'nikita/lib/tools/extract'
    });
    switch (format) {
      case 'tgz':
        cmd = `tar xzf ${options.source} -C ${target} ${tar_opts.join(' ')}`;
        break;
      case 'tar':
        cmd = `tar xf ${options.source} -C ${target} ${tar_opts.join(' ')}`;
        break;
      case 'bz2':
        cmd = `tar xjf ${options.source} -C ${target} ${tar_opts.join(' ')}`;
        break;
      case 'xz':
        cmd = `tar xJf ${options.source} -C ${target} ${tar_opts.join(' ')}`;
        break;
      case 'zip':
        cmd = `unzip -u ${options.source} -d ${target}`;
    }
    return this.system.execute({
      cmd: cmd
    }, function(err, created) {
      if (err) {
        return callback(err);
      }
      return creates();
    });
  };
  // Step for `creates`
  creates = () => {
    if (options.creates == null) {
      return success();
    }
    return this.fs.exists({
      ssh: options.ssh,
      target: options.creates
    }, function(err, {exists}) {
      if (!exists) {
        return callback(Error(`Failed to create '${path.basename(options.creates)}'`));
      }
      return success();
    });
  };
  // Final step
  success = function() {
    return callback(null, true);
  };
  return stat();
};

// ## Dependencies
path = require('path');

misc = require('../misc');
