// Generated by CoffeeScript 2.1.1
var crypto, each, exec, file, fs, glob, ssh2fs;

ssh2fs = require('ssh2-fs');

crypto = require('crypto');

exec = require('ssh2-exec');

each = require('each');

fs = require('fs');

glob = require('./glob');

module.exports = file = {
  copyFile: function(ssh, source, target, callback) {
    var s;
    console.log('deprecated, use nikita.fs.copy instead');
    s = function(ssh, callback) {
      if (!ssh) {
        return callback(null, fs);
      } else {
        return ssh.sftp(callback);
      }
    };
    return s(ssh, function(err, fs) {
      var rs, ws;
      if (err) {
        return callback(err);
      }
      rs = fs.createReadStream(source);
      ws = rs.pipe(fs.createWriteStream(target));
      ws.on('finish', function() {
        var modified;
        if (fs.end) {
          fs.end();
        }
        modified = true;
        return callback();
      });
      return ws.on('error', function(err) {
        if ((!ssh && err.code === 'ENOENT') || (ssh && err.code === 2)) {
          if (err.code === 2) {
            err.code = 'ENOENT';
            err.errno = -2;
            err.syscall = 'open';
            err.path = target;
          }
          err.message = `Invalid Target: no such file or directory, open ${JSON.stringify(target)}`;
        }
        if (fs.end) {
          fs.end();
        }
        return callback(err);
      });
    });
  },
  /*
  Compare modes
  -------------
  */
  copy: function(ssh, source, target, callback) {
    if (!ssh) {
      source = fs.createReadStream(u.pathname);
      source.pipe(target);
      target.on('close', callback);
      return target.on('error', callback);
    } else {
      // todo: use cp to copy over ssh
      return callback(Error('Copy over SSH not yet implemented'));
    }
  },
  /*
  `files.compare(files, callback)`
  --------------------------------
  Compare the hash of multiple file. Return the file md5 
  if the file are the same or false otherwise.
  */
  compare: function(ssh, files, callback) {
    var result;
    if (files.length < 2) {
      return callback(Error('Minimum of 2 files'));
    }
    result = null;
    return each(files).call(function(f, next) {
      return file.hash(ssh, f, function(err, md5) {
        if (err) {
          return next(err);
        }
        if (result === null) {
          result = md5;
        } else if (result !== md5) {
          result = false;
        }
        return next();
      });
    }).next(function(err) {
      if (err) {
        return callback(err);
      }
      return callback(null, result);
    });
  },
  compare_hash: function(ssh1, file1, ssh2, file2, algo, callback) {
    return file.hash(ssh1, file1, algo, function(err, hash1) {
      if (err) {
        return callback(err);
      }
      return file.hash(ssh2, file2, algo, function(err, hash2) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          err = null;
        }
        if (err) {
          return callback(err);
        }
        return callback(null, hash1 === hash2, hash1, hash2);
      });
    });
  },
  /*
  `files.hash(ssh, file, [algorithm], callback)`
  -----------------------------------------
  Retrieve the hash of a supplied file in hexadecimal 
  form. If the provided file is a directory, the returned hash 
  is the sum of all the hashs of the files it recursively 
  contains. The default algorithm to compute the hash is md5.

  Throw an error if file does not exist unless it is a directory.

      file.hash ssh, '/path/to/file', (err, md5) ->
  md5.should.eql '287621a8df3c3f6c99c7b7645bd09ffd'

  */
  hash: function(ssh, file, algorithm, callback) {
    var hasher, hashs;
    if (arguments.length === 3) {
      callback = algorithm;
      algorithm = 'md5';
    }
    hasher = function(ssh, path, callback) {
      var shasum;
      shasum = crypto.createHash(algorithm);
      if (!ssh) {
        return ssh2fs.createReadStream(ssh, path, function(err, stream) {
          if (err) {
            return callback(err);
          }
          return stream.on('data', function(data) {
            return shasum.update(data);
          }).on('error', function(err) {
            if (err.code === 'EISDIR') {
              return callback();
            }
            return callback(err);
          }).on('end', function() {
            return callback(err, shasum.digest('hex'));
          });
        });
      } else {
        return ssh2fs.stat(ssh, path, function(err, stat) {
          if (err) {
            return callback(err);
          }
          if (stat.isDirectory()) {
            return callback();
          }
          return exec({
            cmd: `which openssl >/dev/null || exit 2\nopenssl dgst -${algorithm} ${path} | sed 's/^.* \\([a-z0-9]*\\)$/\\1/g'`,
            ssh: ssh,
            trim: true
          }, function(err, stdout, stderr) {
            if ((err != null ? err.code : void 0) === 2) {
              err = Error("Command does not exist: openssl");
            }
            return callback(err, stdout != null ? stdout.trim() : void 0, stderr != null ? stderr.trim() : void 0);
          });
        });
      }
    };
    hashs = [];
    return ssh2fs.stat(ssh, file, function(err, stat) {
      var compute;
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        err = Error(`Does not exist: ${file}`);
        err.code = 'ENOENT';
        return callback(err);
      }
      if (err) {
        return callback(err);
      }
      if (stat.isFile()) {
        return hasher(ssh, file, callback);
      } else if (stat.isDirectory()) {
        compute = function(files) {
          files.sort();
          return each(files).call(function(item, next) {
            return hasher(ssh, item, function(err, h) {
              if (err) {
                return next(err);
              }
              if (h != null) {
                hashs.push(h);
              }
              return next();
            });
          }).next(function(err) {
            if (err) {
              return callback(err);
            }
            switch (hashs.length) {
              case 0:
                if (stat.isFile()) {
                  return callback(Error(`Does not exist: ${file}`));
                } else {
                  return callback(null, crypto.createHash(algorithm).update('').digest('hex'));
                }
                break;
              case 1:
                return callback(null, hashs[0]);
              default:
                hashs = crypto.createHash(algorithm).update(hashs.join('')).digest('hex');
                return callback(null, hashs);
            }
          });
        };
        return glob(ssh, `${file}/**`, function(err, files) {
          if (err) {
            return callback(err);
          }
          return compute(files);
        });
      } else {
        return callback(Error("File type not supported"));
      }
    });
  }
};
